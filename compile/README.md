# Compiling JetReconstruction.jl to a C-library

Minimal C bindings for JetReconstruction.jl

- [C-header](include/JetReconstruction.h.in)
- shared library compiled with [PackageCompiler.jl](https://github.com/JuliaLang/PackageCompiler.jl) or juliac

## Building library

To build the library, run the following command from the package root directory:

```sh
julia --project=compile compile/build.jl --output-dir JetReconstructionCompiled
```

> [!NOTE]  
> Since Julia 1.12 `--juliac` can be specified to use the juliac compiler instead of PackageCompiler.
> Before Julia 1.12, nightlies can be used instead (make sure to instantiate the main JetReconstruction and `compile` projects with the same version of Julia):
>
> ```sh
> julia +1.12-nightly --project=compile compile/build.jl --juliac
> ```
>
> or
>
> ```sh
> julia +nightly --project=compile compile/build.jl --juliac
> ```
>
> Packages compiled with `PackageCompiler.jl` will have `JETRECONSTRUCTION_COMPILER_PACKAGECOMPILER` defined. Packages compiled with `juliac` will have `JETRECONSTRUCTION_COMPILER_JULIAC` defined.


> [!CAUTION]
> Packages compiled with Julia 1.12 require GLIBCXX_3.4.30 (gcc 12.1.0) or later.

## Usage example

### Example source file

Example usage of C bindings in an application:

```C
#include "JetReconstruction.h"

/*Should be automatically generated by PackageCompiler.jl and distributed together with the "JetReconstruction.h" header file*/
#ifdef JETRECONSTRUCTION_COMPILER_PACKAGECOMPILER
#include "julia_init.h"
#endif

int main(int argc, char *argv[]) {
#ifdef JETRECONSTRUCTION_COMPILER_PACKAGECOMPILER
  init_julia(0, NULL); /*initialization of julia runtime*/
#endif

  /*Prepare array of pseudo jets*/
  size_t particles_len;
  jetreconstruction_PseudoJet* particles;
  /*Initialize with desired values*/

  /*Call jet reconstruction*/
  jetreconstruction_JetAlgorithm algorithm = JETRECONSTRUCTION_JETALGORITHM_CA;
  double R = 3.0;
  jetreconstruction_RecoStrategy strategy = JETRECONSTRUCTION_RECOSTRATEGY_BEST;

  jetreconstruction_ClusterSequence cluster_seq;
  int ret = jetreconstruction_jet_reconstruct(particles, len, algorithm, R, strategy,
                                              &cluster_seq);
  if (ret != JETRECONSTRUCTION_STATUSCODE_OK){
    /*An error occurred check the value or stderr for more information*/
    return 1;
  }

  /*Use the cluster sequence in your application
  then free memory allocations done by library*/
  jetreconstruction_ClusterSequence_free_members(&cluster_seq);
#ifdef JETRECONSTRUCTION_COMPILER_PACKAGECOMPILER
  shutdown_julia(0); /*teardown of julia runtime*/
#endif
  return 0;
}

```

### Example compilation

To build an example application run the following command:

```shell
cc -o jetreconstruction_test compile/downstream/jetreconstruction_test.c -IJetReconstructionCompiled/include -LJetReconstructionCompiled/lib -ljetreconstruction
```

In case the compiled library resides in non-standard location, add its location to `LD_LIBRARY_PATH` when running example application:

```shell
LD_LIBRARY_PATH=JetReconstructionCompiled/lib/:${LD_LIBRARY_PATH} ./jetreconstruction_test
```

### Compilation with CMake

The JetReconstruction library comes with a CMake target `JetReconstruction::JetReconstruction`. Example usage in CMake file:

```cmake
find_package(JetReconstruction REQUIRED)

target_link_libraries(myTarget PUBLIC JetReconstruction::JetReconstruction)
```

## Limitations

Currently it's not possible to create libraries for different platforms - no cross-compilation!

PackageCompiler specific:

- The library is relocatable given the whole installation tree is moved, including libraries in the `lib/julia/` directory.
- It's advised to install the library in a separate directory to avoid possible conflicts.  
  The library must not be installed in the same directory as another Julia package compiled with `PackageCompiler.jl` as they would overwrite the package specific files in `share/julia`.
