var documenterSearchIndex = {"docs":
[{"location":"recombination/#Jet-Recombination","page":"Recombination Schemes","title":"Jet Recombination","text":"","category":"section"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"When two jets are merged different strategies can be adopted to produce the merged jet.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"There are two functions to support this, which can be set by the user and passed as a parameters to the reconstruction algorithms. One function gives the necessary preprocessing for input particles, e.g., setting particles to be massless. The other controls the actual recombination of two particles into a merged jet.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"These functions are passed as the preprocess and recombine parameters to the reconstruction interfaces.","category":"page"},{"location":"recombination/#Default-Four-Vector-Addition","page":"Recombination Schemes","title":"Default - Four Vector Addition","text":"","category":"section"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"The default for jet merging is simply four momentum addition, that is:","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"(mathbfp_m E_m) = (mathbfp_1 + mathbfp_2 E_1 + E_2)","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"This is defined as the addjets function in the package, which also serves as an example of how the recombination functions are written.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"In this case, no preprocessing of particles is required and the default value of preprocess = nothing signals this.","category":"page"},{"location":"recombination/#Different-Recombination-Schemes","page":"Recombination Schemes","title":"Different Recombination Schemes","text":"","category":"section"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"Two additional recombination schemes are directly supported, the p_T and p_T^2 schemes. In these schemes the recombined jet is created to be massless, i.e., the mass is set to the 3-momentum. The transverse momentum is the sum of the two parent jets and the rapidity (y) and phi (phi) values are weighted averages, by p_T or p_T^2, of the parent jets.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"recombine = addjets_ptscheme\nrecombine = addjets_pt2scheme","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"In this case the input particles must be rescaled to be massless, setting the energy equal to the (three) momentum sum.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"preprocess = preprocess_ptscheme\npreprocess = preprocess_pt2scheme","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"(In fact preprocess_pt2scheme is just an alias for preprocess_ptscheme as the rescaling is identical.)","category":"page"},{"location":"recombination/#Named-Recombination-Schemes","page":"Recombination Schemes","title":"Named Recombination Schemes","text":"","category":"section"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"To simplify the usage of different recombination schemes supported directly, there is a defined enum (scoped, using EnumX) for each one: RecombinationScheme.SCHEME.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"This enum is then used with the RecombinationMethods dictionary to obtain a named tuple in which recombine and preprocess are set, which can then be splatted into the jet_reconstruct interface:","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"myscheme = RecombinationMethods[RecombinationScheme.PtScheme]\njet_reconstruct(event; R = distance, p = p, algorithm = algorithm,\n                                 strategy = strategy, myscheme...)","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"The supported values in the enum are:","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"Scheme Implements\nEScheme Default 4-momentum addition\nPtScheme Massless weighted average of momentum\nPt2Scheme Massless weighted average of momentum squared","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"(Should other schemes prove to be particularly desired they can be implemented on request.)","category":"page"},{"location":"recombination/#User-Defined-Recombination","page":"Recombination Schemes","title":"User Defined Recombination","text":"","category":"section"},{"location":"recombination/#Preprocessing","page":"Recombination Schemes","title":"Preprocessing","text":"","category":"section"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"The user must supply, if needed, a preprocessing function, which accepts an input particle and returns the rescaled particle. This function must accept a named argument cluster_hist_index to pass to the constructor of the resulting particle.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"user_preprocess(jet::T; cluster_hist_index) -> T","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"An example of a preprocessing function is preprocess_ptscheme.","category":"page"},{"location":"recombination/#Recombination","page":"Recombination Schemes","title":"Recombination","text":"","category":"section"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"If a different merging scheme is desired then a method must be defined that implements the following interface:","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"user_recombine(jet1::T, jet2::T; cluster_hist_index::Int) where {T <: FourMomentum} -> T","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"i.e., three arguments are needed, the two parent jets and the named argument cluster_hist_index, which is needed to identify the jet in the reconstruction sequence.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"It is recommended to use the constructor signature for the output jet of:","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"T(px, py, pz, E; cluster_hist_index = cluster_hist_index)","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"Where px, py, pz and E have been calculated from the inputs jet1 and jet2 as desired.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"However, if working in (p_T y phi m) space, use the alternative constructor with named parameters:","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"T(;pt=pt, rap=rap, phi=phi, m=m, cluster_hist_index=cluster_hist_index)","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"(Note that there is a default of m=0.0, which is used for massless recombination.)","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"The user function should not modify the cluster_hist_index, but must pass in to the new jet's constructor to ensure that the resulting reconstruction ClusterSequence is valid. The recombination functions defined in the package serve as examples: addjets_ptscheme.","category":"page"},{"location":"recombination/#Using-an-Custom-Recombination-Method","page":"Recombination Schemes","title":"Using an Custom Recombination Method","text":"","category":"section"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"To use a non-default recombination method, simply pass the recombination method to the jet_reconstruct entry point as the recombine parameter and the preprocessing method as preprocess.","category":"page"},{"location":"recombination/","page":"Recombination Schemes","title":"Recombination Schemes","text":"A very convenient way to do this is to bind these functions into a named tuple and splat the tuple into the arguments for the reconstruction.","category":"page"},{"location":"contributing/#Contributing-to-JetReconstruction","page":"Contributing","title":"Contributing to JetReconstruction","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Thank you for your interest in contributing to JetReconstruction.jl. We are very happy to get contributions for:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Bug reports, for things that don't work properly.\nFeature requests, for things that JetReconstruction.jl could do in the future.\nDocumentation improvements, for things that could be better explained.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We ask all contributors to follow the Julia Community Standards - thank you!","category":"page"},{"location":"contributing/#Issues:-Bug-Reports,-Suggestions,-Questions","page":"Contributing","title":"Issues: Bug Reports, Suggestions, Questions","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Raise bug reports and general issues using the issues feature. For bug reports make sure that you:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"are using the latest released version\nexplain how you are running the code\nstate what the problem is clearly\nsay what you would expect the behaviour to be","category":"page"},{"location":"contributing/#New-Features-and-Pull-Requests","page":"Contributing","title":"New Features and Pull Requests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you would like to contribute a new feature to the package it is a good idea to open an issue first, so that you can discuss with the maintainers and check that the feature is in-scope and general enough to warrant direct implementation (as opposed to developing an extension package).","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"There are a few points to bear in mind for development listed below.","category":"page"},{"location":"contributing/#Develop-against-main","page":"Contributing","title":"Develop against main","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Do your development against the head of the main branch so that your code will work with all the other features that are in development at the moment. If main is targetting a breaking change release, e.g., v0.X+1.0 where v0.X is the current version there may be a case for targetting the release-0.X branch if your PR is a bug fix. Please discuss this with the maintainers.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If it takes a while to develop or implement review changes, rebase against main as needed.","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Document all public functions and types using Julia docstrings that will be useful to users.\nAdd docstrings for internal functions too (unless these are trivial) with a focus on helping fellow developers.\nUpdate or add relevant sections in the documentation under docs/src/ as needed.\nProvide clear explanations and usage examples where appropriate.","category":"page"},{"location":"contributing/#Tests","page":"Contributing","title":"Tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"All new features must include tests in test/.\nThe pattern used for implementation is to write a test in test/test-NEW-FEATURE.jl so that the test can be run standalone, and to add an include(\"test-NEW-FEATURE.jl\") into runtests.jl for the CI.\nTo validate the output for a new feature store reference output (e.g., generated by similar functionality in Fastjet) into test/data. Zstd compression is recommended (see the open_with_stream() helper for making this transparent).\nEnsure tests cover edge cases and typical usage.\nRun ] test JetReconstruction or julia --project test/runtests.jl before submitting your PR to verify all tests pass.","category":"page"},{"location":"contributing/#Examples","page":"Contributing","title":"Examples","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add or update usage examples in the documentation or in the examples directory.\nIf your examples require extra packages, e.g., graphics or statistics, please put them into a subdirectory (examples/FEATURE/...) with their own Project.toml.\nExamples should be minimal, clear, and runnable.","category":"page"},{"location":"contributing/#Formatting","page":"Contributing","title":"Formatting","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The code in this repository is formatted with JuliaFormatter. Currently we use version 1 of the formatter so please use this too or the CI may complain.","category":"page"},{"location":"contributing/#Bootstrap","page":"Contributing","title":"Bootstrap","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This is one way to do it:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"$ julia --project=@juliaformatter\n] add JuliaFormatter\n] compat JuliaFormatter 1.0\n] update\n\n$ julia --project=@juliaformatter -e 'using JuliaFormatter; format(\".\")'","category":"page"},{"location":"contributing/#Communication","page":"Contributing","title":"Communication","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Open an issue to discuss major changes before starting work.\nBe responsive to feedback during the review process.","category":"page"},{"location":"contributing/#Pull-Request-Checklist","page":"Contributing","title":"Pull Request Checklist","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Before submitting a PR, please ensure:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"[ ] Code is formatted and linted.\n[ ] All public APIs are documented.\n[ ] New/modified code is covered by tests.\n[ ] Examples are provided or updated.\n[ ] All tests pass locally.","category":"page"},{"location":"contributing/#Some-Development-Tips","page":"Contributing","title":"Some Development Tips","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"As far as possible we follow standard best practice for Julia code. In particular you should be familiar with the following guidelines:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The Julia Style Guide\nJulia Performance Tips","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In addition, here are a few common issues we have seen that you should avoid:","category":"page"},{"location":"contributing/#Don't-use-an-abstract-struct-if-you-are-the-only-sub-type","page":"Contributing","title":"Don't use an abstract struct if you are the only sub-type","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If you want to define functionality in a holistic way with many variables then using a struct is very natural. However, you should not define an abstract super type for your struct unless there will be multiple concrete types.","category":"page"},{"location":"contributing/#Don't-define-accessor-methods-for-internal-variable-access","page":"Contributing","title":"Don't define accessor methods for internal variable access","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"To access struct data, when this is only used internally, just access the member variable directly. Accessors should only be needed if:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This is data a user would want to access, in which case the accessor shields the implementation details.\nThere are many sub-types and an accessor helps to optimise data retrieval.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Thank you for helping improve JetReconstruction!","category":"page"},{"location":"lib/public/#Jet-Reconstruction-Public-Documentation","page":"Public API","title":"Jet Reconstruction Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Documentation for JetReconstruction.jl's public interfaces.","category":"page"},{"location":"lib/public/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Public-Methods-and-Types","page":"Public API","title":"Public Methods and Types","text":"","category":"section"},{"location":"lib/public/#JetReconstruction.addjets-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.addjets","text":"addjets(jet1::T, jet2::T; cluster_hist_index::Int) where {T <: FourMomentum}\n\nAdd jets' four momenta together, returning a new jet of type T with the specified cluster history index.\n\nDetails\n\nThis method is also known as the E_scheme in Fastjet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.addjets_pt2scheme-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.addjets_pt2scheme","text":"addjets_pt2scheme(jet1::T, jet2::T, cluster_hist_index::Int) where {T <: FourMomentum}\n\nUse the massless p_T^2 scheme for combining two jets, setting the appropriate cluster history index for the new jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.addjets_ptscheme-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.addjets_ptscheme","text":"addjets_ptscheme(jet1::T, jet2::T, cluster_hist_index::Int) where {T <: FourMomentum}\n\nUse the massless p_T scheme for combining two jets, setting the appropriate cluster history index for the new jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.constituent_indexes-Union{Tuple{T}, Tuple{T, ClusterSequence{T}}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.constituent_indexes","text":"constituent_indexes(jet::T, cs::ClusterSequence{T}) where T <: FourMomentum\n\nReturn the indexes of the original particles which are the constituents of the given jet.\n\nArguments\n\njet::T: The jet for which to retrieve the constituents.\ncs::ClusterSequence{T}: The cluster sequence object.\n\nReturns\n\nAn vector of indices representing the original constituents of the given jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.constituents-Union{Tuple{T}, Tuple{T, ClusterSequence{T}}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.constituents","text":"constituents(jet::T, cs::ClusterSequence{T}) where T <: FourMomentum\n\nGet a copy of the constituents of a given jet in a cluster sequence.\n\nArguments\n\ncs::ClusterSequence{T}: The cluster sequence object.\njet::T: The jet for which to retrieve the constituents.\n\nReturns\n\nAn array of jet objects (which are of the same type as the input jet) copied from the constituents of the given jet, with reset cluster history indexes.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.ee_genkt_algorithm-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Public API","title":"JetReconstruction.ee_genkt_algorithm","text":"ee_genkt_algorithm(particles::AbstractVector{T}; algorithm::JetAlgorithm.Algorithm,\n                   p::Union{Real, Nothing} = nothing, R = 4.0, recombine = addjets,\n                   preprocess = nothing) where {T}\n\nRun an e+e- reconstruction algorithm on a set of initial particles.\n\nArguments\n\nparticles::AbstractVector{T}: A vector of particles to be clustered.\nalgorithm::JetAlgorithm.Algorithm: The jet algorithm to use.\np::Union{Real, Nothing} = nothing: The power parameter for the algorithm. This is not required for the Durham algorithm, but must be specified for the EEKt` algorithm.\nR = 4.0: The jet radius parameter. Not required and ignored for the Durham algorithm.\nrecombine = addjets: The recombination scheme to use.\npreprocess = nothing: Preprocessing function for input particles.\n\nReturns\n\nThe result of the jet clustering as a ClusterSequence object.\n\nNotes\n\nThis is the public interface to the e+e- jet clustering algorithm. The function will check for consistency between the algorithm and the power parameter as needed. It will then prepare the internal EDM particles for the clustering itself, and call the actual reconstruction method _ee_genkt_algorithm!.\n\nIf the algorithm is Durham, R is nominally set to 4. If the algorithm is EEkt, power p must also be specified.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.exclusive_jets-Union{Tuple{ClusterSequence{U}}, Tuple{U}, Tuple{T}, Tuple{ClusterSequence{U}, Type{T}}} where {T, U}","page":"Public API","title":"JetReconstruction.exclusive_jets","text":"exclusive_jets(clusterseq::ClusterSequence{U}, ::Type{T} = LorentzVectorCyl{Float64}; dcut = nothing, njets = nothing) where {T, U}\n\nReturn all exclusive jets of a ClusterSequence, with either a specific number of jets or a cut on the maximum distance parameter.\n\nArguments\n\nclusterseq::ClusterSequence: The ClusterSequence object containing the clustering history and jets.\n::Type{T} = LorentzVectorCyl{Float64}: The return type used for the selected jets.\ndcut::Union{Nothing, Real}: The distance parameter used to define the exclusive jets. If dcut is provided, the number of exclusive jets will be calculated based on this parameter.\nnjets::Union{Nothing, Integer}: The number of exclusive jets to be calculated. If njets is provided, the distance parameter dcut will be calculated based on this number.\n\nNote: Either dcut or njets must be provided (but not both).\n\nReturns\n\nAn array of T objects representing the exclusive jets.\n\nValid return types are LorentzVectorCyl and the jet type of the input clusterseq (U - either PseudoJet or EEJet depending which algorithm was used) (N.B. this will evolve in the future to be any subtype of FourMomentumBase; currently unrecognised types will return LorentzVectorCyl).\n\nExceptions\n\nArgumentError: If neither dcut nor njets is provided.\nArgumentError: If the algorithm used in the ClusterSequence object is not suitable for exclusive jets.\nErrorException: If the cluster sequence is incomplete and exclusive jets are unavailable.\n\nExamples\n\nexclusive_jets(clusterseq, dcut = 20.0)\nexclusive_jets(clusterseq, PseudoJet, njets = 3)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.final_jets","page":"Public API","title":"JetReconstruction.final_jets","text":"Specialisation for final jets from LorentzVectors (TODO: merge into more general function)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#JetReconstruction.final_jets-2","page":"Public API","title":"JetReconstruction.final_jets","text":"Specialisation for final jets from LorentzVectorCyl (TODO: merge into more general function)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#JetReconstruction.final_jets-3","page":"Public API","title":"JetReconstruction.final_jets","text":"final_jets(jets::Vector{PseudoJet}, ptmin::AbstractFloat=0.0)\n\nThis function takes a vector of PseudoJet objects and a minimum transverse momentum ptmin as input. It returns a vector of FinalJet objects that satisfy the transverse momentum condition.\n\nArguments\n\njets::Vector{PseudoJet}: A vector of PseudoJet objects representing the input jets.\nptmin::AbstractFloat=0.0: The minimum transverse momentum required for a jet to be included in the final jets vector.\n\nReturns\n\nA vector of FinalJet objects that satisfy the transverse momentum condition.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#JetReconstruction.generate_lund_emissions-Tuple{PseudoJet, ClusterSequence{PseudoJet}}","page":"Public API","title":"JetReconstruction.generate_lund_emissions","text":"generate_lund_emissions(jet::PseudoJet, cs::ClusterSequence{PseudoJet})\n\nGenerates the Lund plane emissions for a given jet.  The jet is reclustered using the CA algorithm with a very large R to fully capture the jet structure.\n\nReturns:\n\nlundPoints: A vector of named tuples, each representing one step in the declustering with the following fields:\nh_pt: harder branch pt\ns_pt: softer branch pt\nz: momentum fraction of the softer branch\ndelta: angular distance between branches\nkt: transverse momentum of the softer branch relative to the harder\npsi: azimuthal angle between branches\nkappa: z * ΔR\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.inclusive_jets-Union{Tuple{ClusterSequence{U}}, Tuple{U}, Tuple{T}, Tuple{ClusterSequence{U}, Type{T}}} where {T, U}","page":"Public API","title":"JetReconstruction.inclusive_jets","text":"inclusive_jets(clusterseq::ClusterSequence{U}, ::Type{T} = LorentzVectorCyl{Float64}; ptmin = 0.0) where {T, U}\n\nReturn all inclusive jets of a ClusterSequence with pt > ptmin.\n\nArguments\n\nclusterseq::ClusterSequence: The ClusterSequence object containing the clustering history and jets.\n::Type{T} = LorentzVectorCyl{Float64}: The return type used for the selected jets.\nptmin::Float64 = 0.0: The minimum transverse momentum (pt) threshold for the inclusive jets.\n\nReturns\n\nAn array of T objects representing the inclusive jets.\n\nDescription\n\nThis function computes the inclusive jets from a given ClusterSequence object. It iterates over the clustering history and checks the transverse momentum of each parent jet. If the transverse momentum is greater than or equal to ptmin, the jet is added to the array of inclusive jets.\n\nValid return types are LorentzVectorCyl and the jet type of the input clusterseq (U - either PseudoJet or EEJet depending which algorithm was used) (N.B. this will evolve in the future to be any subtype of FourMomentumBase; currently unrecognised types will return LorentzVectorCyl).\n\nExample\n\ninclusive_jets(clusterseq; ptmin = 10.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.jet_filtering-Tuple{PseudoJet, ClusterSequence{PseudoJet}}","page":"Public API","title":"JetReconstruction.jet_filtering","text":"jet_filtering(jet::PseudoJet, clusterseq::ClusterSequence{PseudoJet}; radius::Real,\n                   hardest_jets::Integer) -> PseudoJet\n\nFilters a jet to retain only the hardest subjets based on a specified radius and number.\n\nArguments:\n\njet::PseudoJet: PseudoJet instance representing the jet to filter.\nclusterseq::ClusterSequence{PseudoJet}: ClusterSequence containing jet history.\nradius::Real: Radius parameter to recluster subjets.\nhardest_jets::Integer: Number of hardest jets to retain in the filtered result.\n\nReturns:\n\nPseudoJet: Filtered jet composed of the hardest subjets.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.jet_reconstruct-Tuple{AbstractVector}","page":"Public API","title":"JetReconstruction.jet_reconstruct","text":"jet_reconstruct(particles::AbstractVector; algorithm::JetAlgorithm.Algorithm,\n                     p::Union{Real, Nothing} = nothing, R = 1.0,\n                     recombine = addjets, preprocess = nothing,\n                     strategy::RecoStrategy.Strategy = RecoStrategy.Best)\n\nReconstructs jets from a collection of particles using a specified algorithm and strategy.\n\nArguments\n\nparticles::AbstractVector: A collection of particles used for jet reconstruction. \nalgorithm::JetAlgorithm.Algorithm: The algorithm to use for jet reconstruction.\np::Union{Real, Nothing} = nothing: The power value used for the distance measure for generalised k_T algorithms (GenKt, EEKt). Other algorithms will ignore this value.\nR = 1.0: The jet radius parameter.\nrecombine = addjets: The recombination scheme used for combining particles.\npreprocess = nothing: The function to preprocess the particles before reconstruction (e.g., for massless schemes). nothing means the particles are not preprocessed.\nstrategy::RecoStrategy.Strategy = RecoStrategy.Best: The jet reconstruction  strategy to use. RecoStrategy.Best makes a dynamic decision based on the  number of starting particles.\n\nNote that p must be specified for GenKt and EEKt algorithms, other algorithms will ignore its value. When an algorithm has no R dependence the R parameter is ignored.\n\nReturns\n\nA cluster sequence object containing the reconstructed jets and the merging history.\n\nDetails\n\nparticles argument\n\nAny type that supplies the methods pt2(), phi(), rapidity(), px(), py(), pz(), energy() (in the JetReconstruction namespace) can be used. This includes LorentzVector, LorentzVectorCyl, PseudoJet and EEJet, for which these methods are already predefined in the JetReconstruction namespace.\n\nNote when using PseudoJet or EEJet, the history indices (_cluster_hist_index) must be set correctly. For initial jets, this means assigning to each jet its index in the vector if you construct them manually. When using other jet types correct indices are set automatically internally.\n\nrecombine argument\n\nThe recombine argument is the function used to merge pairs of particles. The default is addjets, which uses 4-momenta addition (a.k.a. the E-scheme).\n\npreprocess argument\n\nThe preprocess argument is a function that will be called for all original input particles and which returns a new particle, usually matching a non-standard recombination scheme, e.g., massless particles for p_T or p_T^2 recombination. nothing means no preprocessing is done.\n\nExample\n\njet_reconstruct(particles; algorithm = JetAlgorithm.AntiKt, R = 0.4)\njet_reconstruct(particles; algorithm = JetAlgorithm.Kt, R = 1.0)\njet_reconstruct(particles; algorithm = JetAlgorithm.Durham)\njet_reconstruct(particles; algorithm = JetAlgorithm.GenKt, p = 0.5, R = 1.0)\njet_reconstruct(particles; algorithm = JetAlgorithm.AntiKt, R = 1.0, preprocess = preprocess_ptscheme, \n                recombine = addjets_ptscheme)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.jet_trimming-Tuple{PseudoJet, ClusterSequence{PseudoJet}}","page":"Public API","title":"JetReconstruction.jet_trimming","text":"jet_trimming(jet::PseudoJet, clusterseq::ClusterSequence{PseudoJet}; radius::Real,\n                  fraction::Real, recluster_method::JetAlgorithm.Algorithm) -> PseudoJet\n\nTrims a jet by removing subjets with transverse momentum below a specified fraction.\n\nArguments:\n\njet::PseudoJet: PseudoJet instance representing the jet to trim.\nclusterseq::ClusterSequence{PseudoJet}: ClusterSequence containing jet history.\nradius::Real: Radius used for reclustering in trimming.\nfraction::Real: Minimum momentum fraction for retained subjets.\nrecluster_method::JetAlgorithm.Algorithm: Method identifier for reclustering.\n\nReturns:\n\nPseudoJet: Trimmed jet composed of retained subjets.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.kt_scale-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.kt_scale","text":"kt_scale(jet1::T, jet2::T) where {T <: FourMomentum}\n\nComputes the transverse momentum scale as the product of the minimum pt and  the angular separation in the η-ϕ plane (using pseudorapidity).\n\nReturns\n\nThe transverse momentum scale of the two jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.lorentzvector-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.lorentzvector","text":"lorentzvector(jet::T) where {T <: FourMomentum} ->  -> LorentzVector\n\nReturn a cartesian LorentzVector from a jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.lorentzvector_cyl-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.lorentzvector_cyl","text":"lorentzvector_cyl(jet::T) where T <: FourMomentum -> LorentzVectorHEP.LorentzVectorCyl\n\nReturn a cylindrical LorentzVectorCyl from a jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.mass_drop-Tuple{PseudoJet, ClusterSequence{PseudoJet}}","page":"Public API","title":"JetReconstruction.mass_drop","text":"mass_drop(jet::PseudoJet, clusterseq::ClusterSequence{PseudoJet}; mu::Real,\n               y::Real) -> PseudoJet\n\nIdentifies subjets in a jet that pass the mass drop tagging condition. The method stops at the first jet satisfying the mass and distance thresholds.\n\nArguments:\n\njet::PseudoJet: PseudoJet instance representing the jet to tag.\nclusterseq::ClusterSequence{PseudoJet}: ClusterSequence with jet clustering history.\nmu::Real: Maximum allowed mass ratio for a jet to pass tagging.\ny::Real: Minimum kT distance threshold for parent separation.\n\nReturns:\n\nPseudoJet: The jet (or subjet) satisfying the mass drop conditions, if tagging is successful, otherwise invalid_pseudojet object\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.n_exclusive_jets-Tuple{ClusterSequence}","page":"Public API","title":"JetReconstruction.n_exclusive_jets","text":"n_exclusive_jets(clusterseq::ClusterSequence; dcut::AbstractFloat)\n\nReturn the number of exclusive jets of a ClusterSequence that are above a certain dcut value.\n\nArguments\n\nclusterseq::ClusterSequence: The ClusterSequence object containing the clustering history.\ndcut::AbstractFloat: The maximum value for the distance parameter in the reconstruction.\n\nReturns\n\nThe number of exclusive jets in the ClusterSequence object.\n\nExample\n\nn_exclusive_jets(clusterseq, dcut = 20.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.parent_jets-Union{Tuple{T}, Tuple{T, ClusterSequence{T}}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.parent_jets","text":"parent_jets(jet::T, cs::ClusterSequence{T})::Tuple{Union{Nothing, T}, Union{Nothing, T}} where {T <: FourMomentum}\n\nFind the parent jets of a given jet in a cluster sequence.\n\nArguments\n\njet::T: The jet for which to find the parent jets.\ncs::ClusterSequence: The cluster sequence object.\n\nReturns\n\nA tuple of two elements, each of which is either the parent jet object or nothing (if the jet has no parent).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.plain_jet_reconstruct-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Public API","title":"JetReconstruction.plain_jet_reconstruct","text":"plain_jet_reconstruct(particles::AbstractVector{T};\n                      algorithm::JetAlgorithm.Algorithm,\n                      p::Union{Real, Nothing} = nothing, R = 1.0,\n                      recombine = addjets, preprocess = nothing) where {T}\n\nPerform pp jet reconstruction using the plain algorithm.\n\nThe power value maps to specific pp jet reconstruction algorithms, but can be omitted when the algorithm implies the power value to use. It must be specified for the GenKt algorithm.\n\nArguments\n\nparticles::AbstractVector{T}: A vector of particles used for jet  reconstruction, any array of particles, which supports suitable 4-vector  methods, viz. pt2(), phi(), rapidity(), px(), py(), pz(), energy(), can be  used for each element.\nalgorithm::JetAlgorithm.Algorithm: The jet algorithm to use.\np::Union{Real, Nothing} = nothing: The power value used for jet  reconstruction. Must be specified for GenKt algorithm. Other algorithms will  ignore this value.\nR = 1.0: The radius parameter used for jet reconstruction.\nrecombine::Function = addjets: The recombination function used to combine particles into a new jet.\npreprocess::Function = nothing: A function to preprocess the input particles.\n\nNote for the particles argument, the 4-vector methods need to exist in the JetReconstruction package namespace.\n\nThis code will use the k_t algorithm types, operating in (rapidity, φ) space.\n\nReturns\n\nclusterseq: The resulting ClusterSequence object representing the reconstructed jets.\n\nExample\n\njets = plain_jet_reconstruct(particles; algorithm = JetAlgorithm.Kt, R = 1.0)\njets = plain_jet_reconstruct(particles; algorithm = JetAlgorithm.GenKt, p = -0.5, R = 0.4)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.preprocess_pt2scheme","page":"Public API","title":"JetReconstruction.preprocess_pt2scheme","text":"const preprocess_pt2scheme = preprocess_ptscheme\n\nPreprocessing for p_T and p_T^2 schemes are identical.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#JetReconstruction.preprocess_ptscheme-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.preprocess_ptscheme","text":"preprocess_ptscheme(jet::T; cluster_hist_index::Int = 0) -> T where {T <: FourMomentum}\n\nJet preprocessor for the massless p_T schemes, resetting the energy of the jet to be equal to the 3-momentum of the input jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.preprocess_ptscheme-Union{Tuple{OutputT}, Tuple{T}, Tuple{T, Type{OutputT}}} where {T<:JetReconstruction.FourMomentum, OutputT<:JetReconstruction.FourMomentum}","page":"Public API","title":"JetReconstruction.preprocess_ptscheme","text":"preprocess_ptscheme(jet::T, ::Type{OutputT};\n                         cluster_hist_index::Int = 0) -> OutputT where {T <: FourMomentum,\n                                                                        OutputT <: FourMomentum}\n\nJet preprocessor for the massless p_T schemes, resetting the energy of the jet to be equal to the 3-momentum of the input jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.preprocess_ptscheme-Union{Tuple{Union{LorentzVectorHEP.LorentzVector, LorentzVectorHEP.LorentzVectorCyl}}, Tuple{OutputT}, Tuple{Union{LorentzVectorHEP.LorentzVector, LorentzVectorHEP.LorentzVectorCyl}, Type{OutputT}}} where OutputT<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.preprocess_ptscheme","text":"preprocess_ptscheme(particle::Union{LorentzVector, LorentzVectorCyl},\n                         ::Type{OutputT}= PseudoJet,;\n                         cluster_hist_index::Int = 0) -> OutputT where {OutputT <: FourMomentum}\n\nJet preprocessor for the massless p_T schemes, resetting the energy of the jet to be equal to the 3-momentum of the input jet (generic particle type).\n\nDetails\n\nThis function is used to convert a particle of type LorentzVector or LorentzVectorCyl into a jet_type object, which is a subtype of FourMomentum. (This is a work around until LorentzVectorBase can be used, which will make the accessors uniform.)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.pt_fraction-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.pt_fraction","text":"pt_fraction(jet1::T, jet2::T) where T <: FourMomentum\n\nComputes the transverse momentum fraction of the softer of two jets.\n\nReturns\n\nThe transverse momentum fraction of the softer of the two jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.read_final_state_particles-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T","page":"Public API","title":"JetReconstruction.read_final_state_particles","text":"read_final_state_particles(fname, ::Type{T} = PseudoJet; maxevents = -1, skipevents = 0) where {T}\n\nReads final state particles from a file and returns them as a vector of type T.\n\nArguments\n\nfname: The name of the HepMC3 ASCII file to read particles from. If the file is gzipped, the function will automatically decompress it.\n::Type{T}=PseudoJet: The type of object to construct and return.\nmaxevents=-1: The maximum number of events to read. -1 means all events will be read.\nskipevents=0: The number of events to skip before an event is included.\n\nReturns\n\nA vector of vectors of T objects, where each inner vector represents all the particles of a particular event. In particular T can be PseudoJet or a LorentzVector type. Note, if T is not PseudoJet, the order of the arguments in the constructor must be (t, x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.select_ABS_RAP_max-Tuple{Any, Any}","page":"Public API","title":"JetReconstruction.select_ABS_RAP_max","text":"select_ABS_RAP_max(event, absrapmax)\n\nFilter a collection of PseudoJets, returning only those with absolute rapidity less than or equal to absrapmax.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.soft_drop-Tuple{PseudoJet, ClusterSequence{PseudoJet}}","page":"Public API","title":"JetReconstruction.soft_drop","text":"soft_drop(jet::PseudoJet, clusterseq::ClusterSequence{PseudoJet}; zcut::Real,\n               beta::Real, radius::Real = 1.0) -> PseudoJet\n\nApplies soft-drop grooming to remove soft, wide-angle radiation from jets. This function reclusters the jet and iteratively checks the soft-drop condition on subjets.\n\nArguments:\n\njet::PseudoJet: PseudoJet instance to groom.\nclusterseq::ClusterSequence{PseudoJet}: ClusterSequence containing jet history.\nzcut::Real: Minimum allowed energy fraction for subjets.\nbeta::Real: Angular exponent controlling soft radiation suppression.\nradius::Real: The new radius that will be used to recluster the components of the jet, by default set to 1.0.\n\nReturns:\n\nPseudoJet: Groomed jet or invalid_pseudojet object if grooming fails.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.softkiller-Tuple{SoftKiller, Vector{PseudoJet}}","page":"Public API","title":"JetReconstruction.softkiller","text":"softkiller(sk::SoftKiller, event::Vector{PseudoJet})\n\nApply the SoftKiller algorithm to an event (a vector of PseudoJets). Returns a tuple (reduced_event, pt_threshold), where reduced_event is the filtered event and pt_threshold is the computed pt threshold.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.tiled_jet_reconstruct-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Public API","title":"JetReconstruction.tiled_jet_reconstruct","text":"tiled_jet_reconstruct(particles::AbstractVector{T};\n                      algorithm::JetAlgorithm.Algorithm,\n                      p::Union{Real, Nothing} = nothing, R = 1.0,\n                      recombine = addjets, preprocess = nothing) where {T}\n\nMain jet reconstruction algorithm entry point for reconstructing jets using the tiled strategy for generic jet type T.\n\nThis code will use the k_t algorithm types, operating in (rapidity, φ) space.\n\nIt is not necessary to specify both the algorithm and the p (power) value. If both are given they must be consistent or an exception is thrown.\n\nArguments\n\nparticles::AbstractVector{T}: A vector of particles used as input for jet reconstruction. T must support methods px, py, pz and energy (defined in the JetReconstruction namespace).\nalgorithm::JetAlgorithm.Algorithm: The jet algorithm to use.\np::Union{Real, Nothing} = nothing: The power value used for jet reconstruction. Must be specified for GenKt algorithm. Other algorithms will ignore this value.\nR = 1.0: The jet radius parameter for the jet reconstruction algorithm.\nrecombine::Function = addjets: The recombination function used to combine particles into a new jet.\npreprocess::Function = nothing: A function to preprocess the input particles.\n\nReturns\n\nClusterSequence: The resulting ClusterSequence object representing the reconstructed jets.\n\nExample\n\ntiled_jet_reconstruct(particles::Vector{LorentzVectorHEP}; algorithm = JetAlgorithm.GenKt, p = 0.5, R = 0.4)\ntiled_jet_reconstruct(particles::Vector{LorentzVectorHEP}; algorithm = JetAlgorithm.AntiKt, R = 0.4)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.ClusterSequence","page":"Public API","title":"JetReconstruction.ClusterSequence","text":"struct ClusterSequence\n\nA struct holding the full history of a jet clustering sequence, including the final jets.\n\nFields\n\nalgorithm::JetAlgorithm.Algorithm: The algorithm used for clustering.\nstrategy::RecoStrategy.Strategy: The strategy used for clustering.\npower::Float64: The power value used for the clustering algorithm (not that this value is always stored as a Float64 to be type stable)\nR::Float64: The R parameter used for the clustering algorithm.\njets::Vector{T}: The actual jets in the cluster sequence, which are of type T <: FourMomentum.\nn_initial_jets::Int: The initial number of particles used for exclusive jets.\nhistory::Vector{HistoryElement}: The branching history of the cluster sequence. Each stage in the history indicates where to look in the jets vector to get the physical PseudoJet.\nQtot::Any: The total energy of the event.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.ClusterSequence-Union{Tuple{T}, Tuple{JetReconstruction.JetAlgorithm.Algorithm, Real, Float64, JetReconstruction.RecoStrategy.Strategy, Vector{T}, Any, Any}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.ClusterSequence","text":"ClusterSequence(algorithm::JetAlgorithm.Algorithm, p::Real, R::Float64, strategy::RecoStrategy.Strategy, jets::T, history, Qtot) where T <: FourMomentum\n\nConstruct a ClusterSequence object.\n\nArguments\n\nalgorithm::JetAlgorithm.Algorithm: The algorithm used for clustering.\np::Real: The power value used for the clustering algorithm.\nR::Float64: The R parameter used for the clustering algorithm.\nstrategy::RecoStrategy.Strategy: The strategy used for clustering.\njets::Vector{T}: The jets in the cluster sequence, which are of T <: FourMomentum\nhistory::Vector{HistoryElement}: The branching history of the cluster sequence.\nQtot::Any: The total energy of the event.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.EEJet","page":"Public API","title":"JetReconstruction.EEJet","text":"struct EEJet <: FourMomentum\n\nThe EEJet struct is a 4-momentum object used for the e+e jet reconstruction routines.\n\nFields\n\npx::Float64: The x-component of the jet momentum.\npy::Float64: The y-component of the jet momentum.\npz::Float64: The z-component of the jet momentum.\nE::Float64: The energy of the jet.\n_cluster_hist_index::Int: The index of the cluster histogram.\n_p2::Float64: The squared momentum of the jet.\n_inv_p::Float64: The inverse momentum of the jet.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.EEJet-NTuple{4, Real}","page":"Public API","title":"JetReconstruction.EEJet","text":"EEJet(px::Real, py::Real, pz::Real, E::Real, cluster_hist_index::Int)\n\nConstructs an EEJet object from the given momentum components, energy, and cluster history index.\n\nDetails\n\nIf the default value of cluster_hist_index=0 is used, the EEJet cannot be used in a reconstruction sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.EEJet-Tuple{Any}","page":"Public API","title":"JetReconstruction.EEJet","text":"EEJet(jet::Any; cluster_hist_index::Int = 0)\n\nConstruct a EEJet from a generic object jet with the given cluster index. This functions also for LorentzVectorCyl objects.\n\nDetails\n\nThis function is used to convert a generic object jet into an EEJet, for this to work the object must have the methods px, py, pz, and energy defined, which are used to extract the four-momentum components of the object.\n\nThe cluster_hist_index is optional, but needed if the jet is part of a reconstruction sequence. If not provided, it defaults to 0 as an \"invalid\" value.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.EEJet-Tuple{LorentzVectorHEP.LorentzVector}","page":"Public API","title":"JetReconstruction.EEJet","text":"EEJet(jet::LorentzVector; cluster_hist_index::Int = 0)\n\nConstruct a EEJet from a LorentzVector object with optional cluster index.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.EEJet-Tuple{PseudoJet}","page":"Public API","title":"JetReconstruction.EEJet","text":"EEJet(jet::PseudoJet; cluster_hist_index::Int=0)\n\nConstructs an EEJet from a PseudoJet.\n\nDetails\n\nThe cluster_hist_index is set to the value of the cluster_hist_index of the PseudoJet if 0 is passed. Otherwise it is set to the value, >0, passed in.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.FinalJet","page":"Public API","title":"JetReconstruction.FinalJet","text":"struct FinalJet\n\nA struct representing the final properties of a jet, used for JSON serialisation.\n\nFields\n\nrap::Float64: The rapidity of the jet.\nphi::Float64: The azimuthal angle of the jet.\npt::Float64: The transverse momentum of the jet.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.FinalJets","page":"Public API","title":"JetReconstruction.FinalJets","text":"struct FinalJets\n\nA struct with the vector of all jets for a certain jet identifier, used for JSON serialisation.\n\nFields\n\njetid::Int64: The ID of the jet.\njets::Vector{FinalJet}: A vector of FinalJet objects representing the jets.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.PseudoJet","page":"Public API","title":"JetReconstruction.PseudoJet","text":"struct PseudoJet <: FourMomentum\n\nThe PseudoJet struct represents a pseudojet, a four-momentum object used in jet reconstruction algorithms. Additional information for the link back into the history of the clustering is stored in the _cluster_hist_index field. There is caching of the more expensive calculations for rapidity and azimuthal angle.\n\nFields\n\npx::Float64: The x-component of the momentum.\npy::Float64: The y-component of the momentum.\npz::Float64: The z-component of the momentum.\nE::Float64: The energy component of the momentum.\n_cluster_hist_index::Int: The index of the cluster history.\n_pt2::Float64: The squared transverse momentum.\n_inv_pt2::Float64: The inverse squared transverse momentum.\n_rap::Float64: The rapidity.\n_phi::Float64: The azimuthal angle.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.PseudoJet-NTuple{4, Real}","page":"Public API","title":"JetReconstruction.PseudoJet","text":"PseudoJet(px::Real, py::Real, pz::Real, E::Real; cluster_hist_index::Int = 0)\n\nConstruct a PseudoJet from a four momentum (px, py, pz, E)with cluster indexclusterhistindex`.\n\nDetails\n\nIf the (default) value of cluster_hist_index=0 is used, the PseudoJet cannot be used in a reconstruction sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.PseudoJet-Tuple{Any}","page":"Public API","title":"JetReconstruction.PseudoJet","text":"PseudoJet(jet::Any; cluster_hist_index::Int = 0)\n\nConstruct a PseudoJet from a generic object jet with the given cluster index.\n\nDetails\n\nThis function is used to convert a generic object jet into a PseudoJet, for this to work the object must have the methods px, py, pz, and energy defined, which are used to extract the four-momentum components of the object.\n\nThe cluster_hist_index is optional, but needed if the jet is part of a reconstruction sequence. If not provided, it defaults to 0 as an \"invalid\" value.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.PseudoJet-Tuple{EEJet}","page":"Public API","title":"JetReconstruction.PseudoJet","text":"PseudoJet(jet::EEJet)\n\nConstructs a PseudoJet object from an EEJet object, with the same four momentum and cluster history index.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.PseudoJet-Tuple{LorentzVectorHEP.LorentzVectorCyl}","page":"Public API","title":"JetReconstruction.PseudoJet","text":"PseudoJet(jet::LorentzVectorCyl; cluster_hist_index::Int = 0)\n\nConstruct a PseudoJet from a LorentzVectorCyl object with the given cluster index.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.PseudoJet-Tuple{LorentzVectorHEP.LorentzVector}","page":"Public API","title":"JetReconstruction.PseudoJet","text":"PseudoJet(jet::LorentzVector; cluster_hist_index::Int = 0)\n\nConstruct a PseudoJet from a LorentzVector object with the cluster index.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.PseudoJet-Tuple{}","page":"Public API","title":"JetReconstruction.PseudoJet","text":"PseudoJet(;pt::Real, rap::Real, phi::Real, m::Real = 0, cluster_hist_index::Int = 0)\n\nConstruct a PseudoJet from (pt, y, ϕ, m) with the cluster index cluster_hist_index.\n\nDetails\n\nIf the (default) value of cluster_hist_index=0 is used, the PseudoJet cannot be used in a reconstruction sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.SoftKiller","page":"Public API","title":"JetReconstruction.SoftKiller","text":"struct SoftKiller\n\nImplements the SoftKiller pileup mitigation algorithm, inspired by the FastJet contrib package.\n\nThe original algorithm is described in: https://arxiv.org/abs/1407.0408 by Matteo Cacciari, Gavin P. Salam, Gregory Soyez\n\nThis version inspired by the SoftKiller implementation in the FastJet contrib package Original C++ code: https://fastjet.hepforge.org/contrib/\n\nThe SoftKiller algorithm divides the rapidity-phi plane into a grid of tiles and determines a dynamic pt threshold by finding the median of the maximum pt in each tile. Particles with pt below this threshold are removed from the event.\n\nFields\n\n_ymax::Float64: Maximum rapidity of the grid.\n_ymin::Float64: Minimum rapidity of the grid.\n_requested_drap::Float64: Requested grid spacing in rapidity.\n_requested_dphi::Float64: Requested grid spacing in phi.\n_ntotal::Int: Total number of tiles.\n_dy::Float64: Actual grid spacing in rapidity.\n_dphi::Float64: Actual grid spacing in phi.\n_cell_area::Float64: Area of a single tile.\n_inverse_dy::Float64: Inverse of rapidity grid spacing.\n_inverse_dphi::Float64: Inverse of phi grid spacing.\n_ny::Int: Number of tiles in rapidity.\n_nphi::Int: Number of tiles in phi.\n\nConstructors\n\nSoftKiller(rapmin::Float64, rapmax::Float64, drap::Float64, dphi::Float64):  Construct a grid from rapmin to rapmax in rapidity, with tile sizes drap and dphi.\nSoftKiller(rapmax::Float64, grid_size::Float64):  Construct a square grid from -rapmax to rapmax in rapidity, with tile size grid_size.\n\n\n\n\n\n","category":"type"},{"location":"particles/#Input-Particle-Types","page":"Particle Inputs","title":"Input Particle Types","text":"","category":"section"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"For the particles input to the reconstruction any one dimensional AbstractArray{T, 1} can be used, where the type T has to implement methods to extract the 4-vector components, viz, the following are required:","category":"page"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"JetReconstuction.px(particle::T)\nJetReconstuction.py(particle::T)\nJetReconstuction.pz(particle::T)\nJetReconstuction.energy(particle::T)","category":"page"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"Currently built-in supported types are LorentzVectorHEP, the PseudoJet and EEJets from this package, and ReconstructedParticles from EDM4hep Inputs.","category":"page"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"If you require support for a different input collection type then ensure you define the px(), etc. methods for your specific type and in the JetReconstruction package. This use of what might be considered type piracy is blessed as long as you are en end user of the jet reconstruction package.","category":"page"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"If your type is used in several places or by different users, please consider writing a package extension that will support your type, following the model for EDM4hep in ext/EDM4hepJets.jl.","category":"page"},{"location":"EDM4hep/#EDM4hep-Inputs","page":"EDM4hep","title":"EDM4hep Inputs","text":"","category":"section"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"Extension functionality to read EDM4hep ReconstructedParticles, using the EDM4hep.jl package.","category":"page"},{"location":"EDM4hep/#Examples","page":"EDM4hep","title":"Examples","text":"","category":"section"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"EDM4hep ReconstructedParticles can be used as direct input into jet reconstruction.","category":"page"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"A number of working examples are maintained in the EDM4hep examples directory of the package's examples.","category":"page"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"Here is a snippet that shows the main steps:","category":"page"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"using EDM4hep\nusing EDM4hep.RootIO\nusing JetReconstruction\n\n# Change this to something that works on your system\ninput_file = joinpath(\"directory\", \"EDM4hep.root\")\nreader = RootIO.Reader(input_file)\nevents = RootIO.get(reader, \"events\")\n\nevt = events[1]\n\nrecps = RootIO.get(reader, evt, \"ReconstructedParticles\")\n\ncs = jet_reconstruct(recps; algorithm = JetAlgorithm.Durham)","category":"page"},{"location":"EDM4hep/#Function-Index","page":"EDM4hep","title":"Function Index","text":"","category":"section"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"Pages = [\"EDM4hep.md\"]","category":"page"},{"location":"EDM4hep/#EDM4hep-Interfaces","page":"EDM4hep","title":"EDM4hep Interfaces","text":"","category":"section"},{"location":"EDM4hep/#JetReconstruction.energy-Tuple{ReconstructedParticle}","page":"EDM4hep","title":"JetReconstruction.energy","text":"JetReconstruction.energy(recoparticle::ReconstructedParticle)\n\nReturn the energy component of a ReconstructedParticle's four vector.\n\n\n\n\n\n","category":"method"},{"location":"EDM4hep/#JetReconstruction.px-Tuple{ReconstructedParticle}","page":"EDM4hep","title":"JetReconstruction.px","text":"JetReconstruction.px(recoparticle::ReconstructedParticle)\n\nReturn the x component of the momentum of a ReconstructedParticle.\n\n\n\n\n\n","category":"method"},{"location":"EDM4hep/#JetReconstruction.py-Tuple{ReconstructedParticle}","page":"EDM4hep","title":"JetReconstruction.py","text":"JetReconstruction.py(recoparticle::ReconstructedParticle)\n\nReturn the y component of the momentum of a ReconstructedParticle.\n\n\n\n\n\n","category":"method"},{"location":"EDM4hep/#JetReconstruction.pz-Tuple{ReconstructedParticle}","page":"EDM4hep","title":"JetReconstruction.pz","text":"JetReconstruction.pz(recoparticle::ReconstructedParticle)\n\nReturn the z component of the momentum of a ReconstructedParticle.\n\n\n\n\n\n","category":"method"},{"location":"softkiller/#SoftKiller","page":"SoftKiller","title":"SoftKiller","text":"","category":"section"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"The SoftKiller algorithm is a pileup mitigation technique for jet reconstruction in high-energy physics. It is designed to suppress the effect pileup by removing low-p_T particles before jet clustering.","category":"page"},{"location":"softkiller/#Overview","page":"SoftKiller","title":"Overview","text":"","category":"section"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"SoftKiller divides the rapidity-azimuth (ytext-phi) plane into a regular grid. In each grid cell, it determines a p_T threshold such that at least one particle per cell survives. All particles with p_T below this threshold are removed. This approach efficiently reduces pileup contamination while preserving the hard event structure.","category":"page"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"The method is described in Cacciari, Salam, Soyez, Eur. Phys. J. C75 (2015) 59.","category":"page"},{"location":"softkiller/#Interface","page":"SoftKiller","title":"Interface","text":"","category":"section"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"The main interface for SoftKiller is the softkiller function, which is used as follows:","category":"page"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"using JetReconstruction\n\nsk = SoftKiller(rapmax=5.0, grid_size=0.4)\nfiltered_particles, pt_threshold = softkiller(sk, particles)","category":"page"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"particles is a collection of PseudoJet objects (see Input Particle Types).\nrapmax sets the maximum rapidity considered.\ngrid_size sets the size of each grid cell in rapidity and azimuthal angle.","category":"page"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"The function returns the filtered list of particles and the computed p_T threshold.","category":"page"},{"location":"softkiller/#Example","page":"SoftKiller","title":"Example","text":"","category":"section"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"A typical workflow using SoftKiller is:","category":"page"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"using JetReconstruction\n\n# Read event particles (see examples/softkiller/softkiller_plots.jl)\nparticles = read_final_state_particles(\"event.hepmc3\", PseudoJet)[1]\n\n# Set up SoftKiller\nsk = SoftKiller(rapmax=5.0, grid_size=0.4)\n\n# Apply SoftKiller\nfiltered_particles, pt_threshold = softkiller(sk, particles)\n\n# Cluster jets as usual\ncs = jet_reconstruct(filtered_particles; algorithm=JetAlgorithm.AntiKt, R=0.4)\njets = inclusive_jets(cs, ptmin=25.0)","category":"page"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"See [examples/softkiller/softkiller_plots.jl] and [examples/softkiller/softkiller_runtime.jl] for more specific working examples.","category":"page"},{"location":"softkiller/#Parameters","page":"SoftKiller","title":"Parameters","text":"","category":"section"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"Parameter Description Default\nrapmax Maximum rapidity for grid 5.0\ngrid_size Size of grid cell in rapidity-azimuth 0.4","category":"page"},{"location":"softkiller/#Integration","page":"SoftKiller","title":"Integration","text":"","category":"section"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"SoftKiller is typically used as a preprocessing step before jet clustering. It is compatible with all jet algorithms provided by this package and is especially useful in high pileup environments.","category":"page"},{"location":"softkiller/#References","page":"SoftKiller","title":"References","text":"","category":"section"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"M. Cacciari, G. P. Salam, G. Soyez, Eur. Phys. J. C75 (2015) 59\nSoftKiller in FastJet and (https://phab.hepforge.org/source/fastjetsvn/browse/contrib/contribs/SoftKiller/tags/1.0.0/)","category":"page"},{"location":"softkiller/#Authors","page":"SoftKiller","title":"Authors","text":"","category":"section"},{"location":"softkiller/","page":"SoftKiller","title":"SoftKiller","text":"The SoftKiller implementation in this package follows the approach described in the original paper and is integrated with the native Julia jet reconstruction algorithms.","category":"page"},{"location":"lib/internal/#Jet-Reconstruction-Internal-Documentation","page":"Internal API","title":"Jet Reconstruction Internal Documentation","text":"","category":"section"},{"location":"lib/internal/","page":"Internal API","title":"Internal API","text":"Documentation for JetReconstruction.jl's internal methods and types.","category":"page"},{"location":"lib/internal/","page":"Internal API","title":"Internal API","text":"N.B. no guarantee is made of stability of these interfaces or types.","category":"page"},{"location":"lib/internal/#Index","page":"Internal API","title":"Index","text":"","category":"section"},{"location":"lib/internal/","page":"Internal API","title":"Internal API","text":"Pages = [\"internal.md\"]","category":"page"},{"location":"lib/internal/#Internal-Methods-and-Types","page":"Internal API","title":"Internal Methods and Types","text":"","category":"section"},{"location":"lib/internal/#Base.:+-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"Base.:+","text":"+(jet1::T, jet2::T) where {T <: FourMomentum}\n\nAdds two four-momentum vectors together, returning a new jet.\n\nDetails\n\nThis addition operation will return a jet with the cluster history index set to\n\n*This means that this jet cannot be used, or be part of, any clustering\n\nhistory.*\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Base.copy-Tuple{JetReconstruction.TiledJet}","page":"Internal API","title":"Base.copy","text":"copy(j::TiledJet)\n\nCreate a copy of a TiledJet object.\n\nArguments\n\nj::TiledJet: The TiledJet object to be copied.\n\nReturns\n\nA new TiledJet object with the same attributes as the input object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Base.isvalid-Tuple{JetReconstruction.TiledJet}","page":"Internal API","title":"Base.isvalid","text":"isvalid(t::TiledJet)\n\nCheck if a TiledJet is valid, by seeing if it is not the noTiledJet object.\n\nArguments\n\nt::TiledJet: The TiledJet object to check.\n\nReturns\n\nBool: true if the TiledJet object is valid, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Base.isvalid-Tuple{PseudoJet}","page":"Internal API","title":"Base.isvalid","text":"isvalid(j::PseudoJet)\n\nFunction to check whether a given PseudoJet object is non-zero or not. Primarily to use for checking the validity of outputs of substructure tagging.\n\nReturns\n\nBool: true if the PseudoJet object is non-zero (valid), false otherwise. \n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Base.iterate","page":"Internal API","title":"Base.iterate","text":"Base.iterate(t::neighbour_tiles, state=1)\n\nIterate over the neighbour_tiles object, returning all the neighbour tiles for a given Cartesian tile index.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#Base.iterate-2","page":"Internal API","title":"Base.iterate","text":"Base.iterate(t::rightmost_tiles, state=1)\n\nIterate over the rightmost_tiles object, returning all the rightmost tiles for a given Cartesian tile index.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#Base.iterate-Tuple{JetReconstruction.TiledJet}","page":"Internal API","title":"Base.iterate","text":"Base.iterate(tj::TiledJet)\n\nIterate over a TiledJet object's linked list, walking over all jets until the end (then the next jet is invalid).\n\nArguments\n\ntj::TiledJet: The TiledJet object to start to iterate over.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Base.show-Tuple{IO, JetReconstruction.FourMomentum}","page":"Internal API","title":"Base.show","text":"show(io::IO, jet::FourMomentum)\n\nPrint core information about the four-momentum vector of jet to the given IO stream.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Base.show-Tuple{IO, SoftKiller}","page":"Internal API","title":"Base.show","text":"show(io::IO, sk::SoftKiller)\n\nPretty-print the SoftKiller grid configuration.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.CosTheta-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.CosTheta","text":"CosTheta(jet::T) where {T <: FourMomentum}\n\nCompute the cosine of the angle between the momentum vector of jet and the z-axis.\n\nReturns\n\nThe cosine of the angle between the jet and the z-axis.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.E","page":"Internal API","title":"JetReconstruction.E","text":"Alias for energy function\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#JetReconstruction._addjets_with_scale-Union{Tuple{T}, Tuple{Real, Real, T, T, Int64}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction._addjets_with_scale","text":"_addjets_with_scale(scale1::Real, scale2::Real, jet1::T, jet2::T, cluster_hist_index::Int) where {T <: FourMomentum}\n\nCombine two jets as massless objects using the given scale factors for each jet, and return the new jet with the cluster history index set.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._ee_genkt_algorithm!-Tuple{AbstractVector{EEJet}}","page":"Internal API","title":"JetReconstruction._ee_genkt_algorithm!","text":"_ee_genkt_algorithm!(particles::AbstractVector{EEJet};\n                    algorithm::JetAlgorithm.Algorithm, p::Real, R = 4.0,\n                    recombine = addjets)\n\nThis function is the internal implementation of the e+e- jet clustering algorithm. It takes a vector of EEJet particles representing the input particles and reconstructs jets based on the specified parameters.\n\nUsers of the package should use the ee_genkt_algorithm function as their entry point to this jet reconstruction.\n\nArguments\n\nparticles::AbstractVector{EEJet}: A vector of EEJet particles used as input for jet reconstruction. This vector must supply the correct cluster_hist_index values and will be mutated as part of the returned ClusterSequence.\nalgorithm::JetAlgorithm.Algorithm: The jet reconstruction algorithm to use.\np::Real: The power to which the transverse momentum (pt) of each particle is raised.\nR = 4.0: The jet radius parameter.\nrecombine = addjets: The recombination function used to merge two jets.\n\nReturns\n\nclusterseq: The resulting ClusterSequence object representing the reconstructed jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._plain_jet_reconstruct!-Tuple{AbstractVector{PseudoJet}}","page":"Internal API","title":"JetReconstruction._plain_jet_reconstruct!","text":"_plain_jet_reconstruct!(particles::AbstractVector{PseudoJet};\n                       algorithm::JetAlgorithm.Algorithm, p::Real, R = 1.0,\n                       recombine = addjets)\n\nThis is the internal implementation of jet reconstruction using the plain algorithm. It takes a vector of PseudoJet particles representing the input particles and reconstructs jets based on the specified parameters.\n\nUsers of the package should use the plain_jet_reconstruct function as their entry point to this jet reconstruction.\n\nArguments\n\nparticles::AbstractVector{PseudoJet}: A vector of PseudoJet particles used as input for jet reconstruction. This vector must supply the correct cluster_hist_index values and will be mutated as part of the returned ClusterSequence.\nalgorithm::JetAlgorithm.Algorithm: The jet reconstruction algorithm to use.\np::Real: The power to which the transverse momentum (pt) of each particle is raised.\nR = 1.0: The jet radius parameter.\nrecombine = addjets: The recombination scheme to use.\n\nReturns\n\nclusterseq: The resulting ClusterSequence object representing the reconstructed jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._tiled_jet_reconstruct!-Tuple{AbstractVector{PseudoJet}}","page":"Internal API","title":"JetReconstruction._tiled_jet_reconstruct!","text":"_tiled_jet_reconstruct!(particles::AbstractVector{PseudoJet};\n                       algorithm::JetAlgorithm.Algorithm,\n                       p::Real, R = 1.0, recombine = addjets)\n\nMain jet internal reconstruction algorithm entry point for reconstructing jets once preprocessing of data types are done. The algorithm parameter must be consistent with the power parameter.\n\nArguments\n\nparticles::AbstractVector{PseudoJet}: A vector of PseudoJet particles used as input for jet reconstruction. This vector must supply the correct cluster_hist_index values and will be mutated as part of the returned ClusterSequence.\nalgorithm::JetAlgorithm.Algorithm: The jet reconstruction algorithm to use.\np::Real: The power parameter for the jet reconstruction algorithm, thus switching between different algorithms.\nR = 1.0: The jet radius parameter for the jet reconstruction algorithm.\nrecombine::Function = addjets: The recombination function used for combining pseudojets.\n\nReturns\n\nclusterseq: The resulting ClusterSequence object representing the reconstructed jets.\n\nExample\n\n_tiled_jet_reconstruct!(particles::Vector{PseudoJet}; algorithm = JetAlgorithm.Kt, p = 1, R = 0.4)\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._tj_diJ-Tuple{Any}","page":"Internal API","title":"JetReconstruction._tj_diJ","text":"_tj_diJ(jet)\n\nCompute the dij metric value for a given jet.\n\nArguments\n\njet: The input jet.\n\nReturns\n\nThe dij value for the jet.\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._tj_dist-Tuple{Any, Any}","page":"Internal API","title":"JetReconstruction._tj_dist","text":"_tj_dist(jetA, jetB)\n\nCompute the geometric distance in the (y, ϕ)-plane between two jets in the TiledAlgoLL module.\n\nArguments\n\njetA: The first jet.\njetB: The second jet.\n\nReturns\n\nThe squared distance between jetA and jetB.\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.add_step_to_history!-Tuple{ClusterSequence, Vararg{Any, 4}}","page":"Internal API","title":"JetReconstruction.add_step_to_history!","text":"add_step_to_history!(clusterseq::ClusterSequence, parent1, parent2, jetp_index, dij)\n\nAdd a new jet's history into the recombination sequence.\n\nArguments:\n\nclusterseq::ClusterSequence: The cluster sequence object.\nparent1: The index of the first parent.\nparent2: The index of the second parent.\njetp_index: The index of the jet.\ndij: The dij value.\n\nThis function adds a new HistoryElement to the history vector of the clusterseq object. The HistoryElement contains information about the parents, child, jet index, dij value, and the maximum dij value so far. It also updates the child index of the parent elements.\n\nIf the parent1 or parent2 have already been recombined, an InternalError is thrown. The jetp_index is used to update the _cluster_hist_index of the corresponding PseudoJet object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.add_untagged_neighbours_to_tile_union-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.add_untagged_neighbours_to_tile_union","text":"add_untagged_neighbours_to_tile_union(center_index, tile_union, n_near_tiles, tiling)\n\nAdds to the vector tileunion the tiles that are in the neighbourhood of the specified centerindex, including itself and whose tagged status are false - start adding from position nneartiles-1, and increase nneartiles. When a neighbour is added its tagged status is set to true.\n\nArguments\n\ncenter_index: The index of the center tile.\ntile_union: An array to store the indices of neighbouring tiles.\nn_near_tiles: The number of neighbouring tiles.\ntiling: The tiling object containing the tile tags.\n\nReturns\n\nThe updated number of near tiles.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.addjets_escheme","page":"Internal API","title":"JetReconstruction.addjets_escheme","text":"const addjets_escheme = addjets\n\nAlias for the addjets function, which is the default jet recombination scheme.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#JetReconstruction.angular_distance-Tuple{Any, Any, Any}","page":"Internal API","title":"JetReconstruction.angular_distance","text":"angular_distance(eereco, i, j) -> Float64\n\nCalculate the angular distance between two jets i and j using the formula 1 - cos(θ_ij).\n\nArguments\n\neereco: The array of EERecoJet objects.\ni: The first jet.\nj: The second jet.\n\nReturns\n\nFloat64: The angular distance between i and j, which is 1 - cos\theta.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.cluster_hist_index-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.cluster_hist_index","text":"cluster_hist_index(j::FourMomentum)\n\nReturn the cluster history index of the jet j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.copy_to_slot!-Tuple{Any, Any, Any}","page":"Internal API","title":"JetReconstruction.copy_to_slot!","text":"copy_to_slot!(eereco, i, j)\n\nCopy the contents of slot i in the eereco array to slot j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.decluster-Union{Tuple{T}, Tuple{T, ClusterSequence{T}}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.decluster","text":"decluster(jet::T, clusterseq::ClusterSequence{T}) where {T <: FourMomentum}\n\nGiven a jet and its clustering sequence, this function attempts to  decluster it into its two parent subjets. If both parents exist, it  returns them ordered by descending pt².\n\nReturns:\n\n(j1, j2) where j1 is the harder subjet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.deltaR-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.deltaR","text":"deltaR(jet1::T, jet2::T) where T <: FourMomentum\n\nFunction to calculate the distance in the y-ϕ plane between two jets jet1 and jet2 (that is using rapidity and azimuthal angle).\n\nReturns\n\nThe Euclidean distance in the y-ϕ plane for the two jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.delta_phi-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.delta_phi","text":"delta_phi(jet1::T, jet2::T) where {T <: FourMomentum}\n\nComputes the difference in azimuthal angle φ between two jets, wrapped into the range [-π, π].\n\nReturns\n\nδφ as a Float64 in radians.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.deltar-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.deltar","text":"deltar(jet1::T, jet2::T) where T <: FourMomentum\n\nFunction to calculate the distance in the η-ϕ plane between two jets jet1 and jet2 (that is, using the pseudorapidity and azimuthal angle).\n\nReturns\n\nThe Euclidean distance in the η-ϕ plane for the two jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.detach!-Tuple{JetReconstruction.TiledJet}","page":"Internal API","title":"JetReconstruction.detach!","text":"detach!(jet::TiledJet)\n\nDetach a TiledJet from its linked list by updating the previous and next pointers.\n\nArguments\n\njet::TiledJet: The TiledJet object to detach.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.determine_rapidity_extent-Union{Tuple{Vector{T}}, Tuple{T}} where T<:AbstractFloat","page":"Internal API","title":"JetReconstruction.determine_rapidity_extent","text":"determine_rapidity_extent(eta::Vector{T}) where T <: AbstractFloat\n\nCalculate the minimum and maximum rapidities based on the input vector eta. The function determines the rapidity extent by binning the multiplicities as a function of rapidity and finding the minimum and maximum rapidities such that the edge bins contain a certain fraction (~1/4) of the busiest bin and a minimum number of particles.\n\nThis is the heuristic which is used by FastJet (inline comments are from FastJet).\n\nArguments\n\neta::Vector{T}: A vector of rapidity values.\n\nReturns\n\nminrap::T: The minimum rapidity value.\nmaxrap::T: The maximum rapidity value.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.dij-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.dij","text":"dij(i, kt2_array, nn, nndist)\n\nCompute the dij value for a given index i to its nearest neighbor. The nearest neighbor is determined from nn[i], and the metric distance to the nearest neighbor is given by the distance nndist[i] applying the lower of the kt2_array values for the two particles.\n\nArguments\n\ni: The index of the element.\nkt2_array: An array of kt2 values.\nnn: An array of nearest neighbors.\nnndist: An array of nearest neighbor distances.\n\nReturns\n\nThe computed dij value.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.dij_dist-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.dij_dist","text":"dij_dist(eereco, i, j, dij_factor)\n\nCalculate the dij distance between two e^+e^-jets.\n\nArguments\n\neereco: The array of EERecoJet objects.\ni: The first jet.\nj: The second jet.\ndij_factor: The scaling factor to multiply the dij distance by.\n\nReturns\n\nThe dij distance between i and j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.dist-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.dist","text":"dist(i, j, rapidity_array, phi_array)\n\nCompute the distance between points in a 2D space defined by rapidity and phi coordinates.\n\nArguments\n\ni::Int: Index of the first point to consider (indexes into rapidity_array and phi_array).\nj::Int: Index of the second point to consider (indexes into rapidity_array and phi_array).\nrapidity_array::Vector{Float64}: Array of rapidity coordinates.\nphi_array::Vector{Float64}: Array of phi coordinates.\n\nReturns\n\ndistance::Float64: The distance between the two points.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.do_iB_recombination_step!-Tuple{ClusterSequence, Any, Any}","page":"Internal API","title":"JetReconstruction.do_iB_recombination_step!","text":"do_iB_recombination_step!(clusterseq::ClusterSequence, jet_i, diB)\n\nBookkeeping for recombining a jet with the beam (i.e., finalising the jet) by adding a step to the history of the cluster sequence.\n\nArguments\n\nclusterseq::ClusterSequence: The cluster sequence object.\njet_i: The index of the jet.\ndiB: The diB value.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.energy-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.energy","text":"energy(j::FourMomentum)\n\nReturn the energy component of the four-momentum vector of j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.eta-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.eta","text":"eta(jet::T) where {T <: FourMomentum}\n\nCompute the pseudorapidity (η) of a jet.\n\nReturns\n\nThe pseudorapidity (η) of the jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.fast_findmin-Tuple{Any, Any}","page":"Internal API","title":"JetReconstruction.fast_findmin","text":"fast_findmin(dij, n)\n\nFind the minimum value and its index in the first n elements of the dij array. The use of @turbo macro gives a significant performance boost.\n\nArguments\n\ndij: An array of values.\nn: The number of elements to consider in the dij array.\n\nReturns\n\ndij_min: The minimum value in the first n elements of the dij array.\nbest: The index of the minimum value in the dij array.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.find_tile_neighbours!-NTuple{5, Any}","page":"Internal API","title":"JetReconstruction.find_tile_neighbours!","text":"find_tile_neighbours!(tile_union, jetA, jetB, oldB, tiling)\n\nFind the union of neighbouring tiles of jetA, jetB, and oldB and add them to the tile_union. This established the set of tiles over which searches for updated and new nearest-neighbours must be run\n\nArguments\n\ntile_union: The tile union to which the neighbouring tiles will be added.\njetA: The first jet.\njetB: The second jet.\noldB: The old second jet.\ntiling: The tiling information.\n\nReturns\n\nThe number of neighbouring tiles added to the tile_union.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.geometric_distance-NTuple{4, AbstractFloat}","page":"Internal API","title":"JetReconstruction.geometric_distance","text":"geometric_distance(eta1::AbstractFloat, phi1::AbstractFloat, eta2::AbstractFloat, phi2::AbstractFloat)\n\nCompute the geometric distance between two points in the rap-phi plane.\n\nArguments\n\neta1::AbstractFloat: The eta coordinate of the first point.\nphi1::AbstractFloat: The phi coordinate of the first point.\neta2::AbstractFloat: The eta coordinate of the second point.\nphi2::AbstractFloat: The phi coordinate of the second point.\n\nReturns\n\ndistance::Float64: The geometric distance between the two points.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_algorithm_power-Tuple{}","page":"Internal API","title":"JetReconstruction.get_algorithm_power","text":"get_algorithm_power(; algorithm::JetAlgorithm.Algorithm, p::Union{Real, Nothing}) -> Real\n\nGet the algorithm power\n\nThis function returns appropriate power value for the specified jet algorithm if the algorithm is a fixed power algorithm (like AntiKt, CA, Kt, or Durham). If the algorithm is generalized (like GenKt or EEKt), it requires a power value to be specified and the function returns the same value.\n\nArguments\n\np::Union{Real, Nothing}: The power value.\nalgorithm::JetAlgorithm.Algorithm: The algorithm.\n\nReturns\n\nResolved algorithm power value.\n\nThrows\n\nArgumentError: If no power is specified for a generalized algorithm\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_all_ancestors-Tuple{Any, ClusterSequence}","page":"Internal API","title":"JetReconstruction.get_all_ancestors","text":"get_all_ancestors(idx, cs::ClusterSequence)\n\nRecursively finds all ancestors of a given index in a ClusterSequence object.\n\nArguments\n\nidx: The index of the jet for which to find ancestors.\ncs: The ClusterSequence object containing the jet history.\n\nReturns\n\nAn array of indices representing the ancestors of the given jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_dij_dist-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.get_dij_dist","text":"get_dij_dist(nn_dist, kt2_1, kt2_2, R2)\n\nCompute the dij metric distance between two jets.\n\nArguments\n\nnn_dist: The nearest-neighbor distance between two jets.\nkt2_1: The squared momentum metric value of the first jet.\nkt2_2: The squared momentum metric value of the second jet.\nR2: The jet radius parameter squared.\n\nReturns\n\nThe distance between the two jets.\n\nIf kt2_2 is equal to 0.0, then the first jet doesn't actually have a valid  neighbour, so it's treated as a single jet adjacent to the beam.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_tile-Tuple{JetReconstruction.TilingDef, AbstractFloat, AbstractFloat}","page":"Internal API","title":"JetReconstruction.get_tile","text":"get_tile(tiling_setup::TilingDef, eta::AbstractFloat, phi::AbstractFloat)\n\nGiven a tiling_setup object, eta and phi values, this function calculates the tile indices for the given eta and phi values.\n\nArguments\n\ntiling_setup: A TilingDef object that contains the tiling setup parameters.\neta: The eta value for which to calculate the tile index.\nphi: The phi value for which to calculate the tile index.\n\nReturns\n\nieta: The tile index along the eta direction.\niphi: The tile index along the phi direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_tile_cartesian_indices-Tuple{JetReconstruction.TilingDef, Int64}","page":"Internal API","title":"JetReconstruction.get_tile_cartesian_indices","text":"get_tile_linear_index(tiling_setup::TilingDef, i_η::Int, i_ϕ::Int)\n\nCompute the linear index of a tile in a tiled setup. This is much faster in this function than using the LinearIndices construct (like x100, which is bonkers, but there you go...)\n\nArguments\n\ntiling_setup::TilingDef: The tiling setup defining the number of tiles in each dimension.\ni_η::Int: The index of the tile in the η dimension.\ni_ϕ::Int: The index of the tile in the ϕ dimension.\n\nReturns\n\nThe linear index of the tile.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.initial_history-Tuple{Any}","page":"Internal API","title":"JetReconstruction.initial_history","text":"initial_history(particles)\n\nCreate an initial history for the given particles.\n\nArguments\n\nparticles: The initial vector of stable particles.\n\nReturns\n\nhistory: An array of HistoryElement objects.\nQtot: The total energy in the event.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.insert!-Tuple{JetReconstruction.TiledJet, JetReconstruction.TiledJet}","page":"Internal API","title":"JetReconstruction.insert!","text":"insert!(nextjet::TiledJet, jettomove::TiledJet)\n\nInserts a TiledJet object into the linked list of TiledJet objects, before the nextjet object. The jet to move can be an isolated jet, a jet from another list or a jet from the same list\n\nArguments\n\nnextjet::TiledJet: The TiledJet object after which jettomove should be inserted.\njettomove::TiledJet: The TiledJet object to be inserted.\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.is_ee-Tuple{JetReconstruction.JetAlgorithm.Algorithm}","page":"Internal API","title":"JetReconstruction.is_ee","text":"is_ee(algorithm::JetAlgorithm.Algorithm)\n\nCheck if the algorithm is a e+e- reconstruction algorithm.\n\nReturns\n\ntrue if the algorithm is a e+e- reconstruction algorithm, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.is_pp-Tuple{JetReconstruction.JetAlgorithm.Algorithm}","page":"Internal API","title":"JetReconstruction.is_pp","text":"is_pp(algorithm::JetAlgorithm.Algorithm)\n\nCheck if the algorithm is a pp reconstruction algorithm.\n\nReturns\n\ntrue if the algorithm is a pp reconstruction algorithm, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.jet_ranks-Tuple{ClusterSequence}","page":"Internal API","title":"JetReconstruction.jet_ranks","text":"jet_ranks(clusterseq::ClusterSequence; compare_fn = JetReconstruction.pt)\n\nCompute the ranks of jets in a given ClusterSequence object based on a specified comparison function.\n\nArguments\n\nclusterseq::ClusterSequence: The ClusterSequence object containing the jets to rank.\ncompare_fn = JetReconstruction.pt: The comparison function used to determine the order of the jets. Defaults to JetReconstruction.pt, which compares jets based on their transverse momentum.\n\nReturns\n\nA dictionary mapping each jet index to its rank.\n\nNote\n\nThis is a utility function that can be used to rank initial clusters based on a specified jet property. It can be used to assign a consistent \"rank\" to each reconstructed jet in the cluster sequence, which is useful for stable plotting of jet outputs.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.kt2","page":"Internal API","title":"JetReconstruction.kt2","text":"Alias for pt2 function\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#JetReconstruction.m","page":"Internal API","title":"JetReconstruction.m","text":"Alias for mass function\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#JetReconstruction.m2","page":"Internal API","title":"JetReconstruction.m2","text":"Alias for mass2 function\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#JetReconstruction.mag-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.mag","text":"mag(jet::T) where {T <: FourMomentum}\n\nReturn the magnitude of the momentum of a jet, |p|.\n\nReturns\n\nThe magnitude of the jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.mass-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.mass","text":"mass(j::FourMomentum)\n\nReturn the invariant mass of a four momentum j. By convention if m^2  0, then -sqrt(-m^2) is returned.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.mass2-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.mass2","text":"mass2(j::FourMomentum)\n\nReturn the invariant mass squared of the four-momentum vector j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.merge_steps-Tuple{ClusterSequence}","page":"Internal API","title":"JetReconstruction.merge_steps","text":"merge_steps(clusterseq::ClusterSequence)\n\nCompute the number of jet-jet merge steps in a cluster sequence. This is useful to give the number of meaningful recombination steps in a jet reconstruction sequence (beam merge steps are not counted).\n\nArguments\n\nclusterseq::ClusterSequence: The cluster sequence object.\n\nReturns\n\nmerge_steps::Int: The number of merge steps.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.nx-Tuple{EEJet}","page":"Internal API","title":"JetReconstruction.nx","text":"nx(eej::EEJet)\n\nReturn the x-component of the unit vector aligned with the momentum of eej\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.ny-Tuple{EEJet}","page":"Internal API","title":"JetReconstruction.ny","text":"ny(eej::EEJet)\n\nReturn the y-component of the unit vector aligned with the momentum of eej\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.nz-Tuple{EEJet}","page":"Internal API","title":"JetReconstruction.nz","text":"nz(eej::EEJet)\n\nReturn the z-component of the unit vector aligned with the momentum of eej\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.open_with_stream-Tuple{AbstractString}","page":"Internal API","title":"JetReconstruction.open_with_stream","text":"open_with_stream(fname::AbstractString)\n\nOpen a file with a stream decompressor if it is compressed with gzip or zstd, otherwise as a normal file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.p-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.p","text":"p(j::FourMomentum)\n\nReturn the momentum of the four-momentum vector of j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.p2-Tuple{EEJet}","page":"Internal API","title":"JetReconstruction.p2","text":"p2(eej::EEJet)\n\nReturn the squared momentum of the EEJet object eej.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.p2-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.p2","text":"p2(j::FourMomentum)\n\nReturn the squared momentum of the four-momentum vector of j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.phi-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.phi","text":"phi(j::FourMomentum)\n\nReturn the azimuthal angle, ϕ, of the four momentum j in the range [0, 2π).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.phi-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.phi","text":"phi(p::PseudoJet)\n\nReturn the azimuthal angle, ϕ, of a PseudoJet object p in the range [0, 2π).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.pt-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.pt","text":"pt(j::FourMomentum)\n\nReturn the momentum of the four-momentum vector of j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.pt-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.pt","text":"pt(p::PseudoJet)\n\nCompute the scalar transverse momentum (pt) of a PseudoJet.\n\nReturns\n\nThe transverse momentum (pt) of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.pt2-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.pt2","text":"pt2(j::FourMomentum)\n\nReturn the squared transverse momentum of the four-momentum vector of j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.pt2-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.pt2","text":"pt2(p::PseudoJet)\n\nGet the squared transverse momentum of a PseudoJet.\n\nReturns\n\nThe squared transverse momentum of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.px-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.px","text":"px(j::FourMomentum)\n\nReturn the x-component of the four-momentum vector of j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.py-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.py","text":"py(j::FourMomentum)\n\nReturn the y-component of the four-momentum vector of j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.pz-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.pz","text":"pz(j::FourMomentum)\n\nReturn the z-component of the four-momentum vector of j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.rapidity-Tuple{JetReconstruction.FourMomentum}","page":"Internal API","title":"JetReconstruction.rapidity","text":"rapidity(j::FourMomentum)\n\nReturn the rapidity of the four momentum j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.rapidity-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.rapidity","text":"rapidity(p::PseudoJet)\n\nCompute the rapidity of a PseudoJet object.\n\nReturns\n\nThe rapidity of the PseudoJet object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.recluster-Tuple{PseudoJet, ClusterSequence{PseudoJet}}","page":"Internal API","title":"JetReconstruction.recluster","text":"recluster(jet::PseudoJet, clusterseq::ClusterSequence{PseudoJet}; R = 1.0,\n               algorithm::JetAlgorithm.Algorithm = JetAlgorithm.CA) -> PseudoJet\n\nReclusters the constituents of a given jet jet with a different clustering algorithm algorithm and different jet radius R.\n\nArguments\n\njet::PseudoJet: The jet whose constituents are to be reclustered.\nclusterseq::ClusterSequence{PseudoJet}: The cluster sequence from which the original jet is obtained.\nR = 1.0: The new jet radius.\nalgorithm::JetAlgorithm.Algorithm = JetAlgorithm.CA: The new clustering method.\n\nReturns\n\nClusterSequence: The new cluster sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.reco_state-Union{Tuple{T}, Tuple{ClusterSequence{T}, Any}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.reco_state","text":"reco_state(cs::ClusterSequence, pt_ranks; iteration=0)\n\nThis function returns the reconstruction state of a ClusterSequence object based on a given iteration number in the reconstruction.\n\nArguments\n\ncs::ClusterSequence: The ClusterSequence object to update.\nranks: The ranks of the original clusters, that are inherited by pseudojets\n\nduring the reconstruction process.\n\niteration=0: The iteration number to consider for updating the reconstruction state (0 represents the initial state).\nignore_beam_merge=true: Ignore beam merging steps in the reconstruction (which produce no change in status).\n\nReturns\n\nA dictionary representing a snapshot of the reconstruction state.\n\nDetails\n\nThe function starts by initializing the reconstruction state with the initial particles. Then, it walks over the iteration sequence and updates the reconstruction state based on the history of recombination and finalization/beam merger steps.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.rightneighbours-Tuple{Int64, JetReconstruction.Tiling}","page":"Internal API","title":"JetReconstruction.rightneighbours","text":"rightneighbours(center::Int, tiling::Tiling)\n\nCompute the indices of the right neighbors of a given center index in a tiling. This is used in the initial sweep to calculate the nearest neighbors, where the search between jets for the nearest neighbour is bi-directional, thus when a tile is considered only the right neighbours are needed to compare jet distances as the left-hand tiles have been done from that tile already.\n\nArguments\n\ncenter::Int: The center index.\ntiling::Tiling: The tiling object.\n\nReturns\n\nSurrounding: An object containing the indices of the right neighbors.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.set_nearest_neighbours!-Tuple{ClusterSequence, JetReconstruction.Tiling, Vector{JetReconstruction.TiledJet}}","page":"Internal API","title":"JetReconstruction.set_nearest_neighbours!","text":"set_nearest_neighbours!(clusterseq::ClusterSequence, tiling::Tiling, tiledjets::Vector{TiledJet})\n\nThis function sets the nearest neighbor information for all jets in the tiledjets vector.\n\nArguments\n\nclusterseq::ClusterSequence: The cluster sequence object.\ntiling::Tiling: The tiling object.\ntiledjets::Vector{TiledJet}: The vector of tiled jets.\n\nReturns\n\nNNs::Vector{TiledJet}: The vector of nearest neighbor jets.\ndiJ::Vector{Float64}: The vector of diJ values.\n\nThe function iterates over each tile in the tiling and sets the nearest neighbor information for each jet in the tile. It then looks for neighbor jets in the neighboring tiles and updates the nearest neighbor information accordingly. Finally, it creates the diJ table and returns the vectors of nearest neighbor jets and diJ values.\n\nNote: The diJ values are calculated as the kt distance multiplied by R^2.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.setup_tiling-Union{Tuple{T}, Tuple{Vector{T}, AbstractFloat}} where T<:AbstractFloat","page":"Internal API","title":"JetReconstruction.setup_tiling","text":"setup_tiling(eta::Vector{T}, Rparam::AbstractFloat) where T <: AbstractFloat\n\nThis function sets up the tiling parameters for a reconstruction given a vector of rapidities eta and a radius parameter Rparam.\n\nArguments\n\neta::Vector{T}: A vector of rapidities.\nRparam::AbstractFloat: The jet radius parameter.\n\nReturns\n\ntiling_setup: A TilingDef object containing the tiling setup parameters.\n\nDescription\n\nThe function first decides the tile sizes based on the Rparam value. It then determines the number of tiles in the phi direction (n_tiles_phi) based on the tile size. Next, it determines the rapidity extent of the input eta vector and adjusts the values accordingly. Finally, it creates a TilingDef object with the calculated tiling parameters and returns it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.surrounding-Tuple{Int64, JetReconstruction.Tiling}","page":"Internal API","title":"JetReconstruction.surrounding","text":"surrounding(center::Int, tiling::Tiling)\n\nCompute the surrounding indices of a given center index in a tiling.\n\nArguments\n\ncenter::Int: The center index.\ntiling::Tiling: The tiling object.\n\nReturns\n\nSurrounding: An object containing the surrounding indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.tile_index-Tuple{Any, Float64, Float64}","page":"Internal API","title":"JetReconstruction.tile_index","text":"tile_index(tiling_setup, eta::Float64, phi::Float64)\n\nCompute the tile index for a given (eta, phi) coordinate.\n\nArguments\n\ntiling_setup: The tiling setup object containing the tile size and number of tiles.\neta::Float64: The eta coordinate.\nphi::Float64: The phi coordinate.\n\nReturns\n\nThe tile index corresponding to the (eta, phi) coordinate.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.tile_index-Tuple{SoftKiller, PseudoJet}","page":"Internal API","title":"JetReconstruction.tile_index","text":"tile_index(sk::SoftKiller, p::PseudoJet)\n\nReturn the tile index for a given PseudoJet p in the SoftKiller grid sk. Returns -1 if the jet is outside the grid bounds.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.tiledjet_remove_from_tiles!-Tuple{Any, Any}","page":"Internal API","title":"JetReconstruction.tiledjet_remove_from_tiles!","text":"tiledjet_remove_from_tiles!(tiling, jet)\n\nRemove a jet from the given tiling structure.\n\nArguments\n\ntiling: The tiling structure from which the jet will be removed.\njet: The jet to be removed from the tiling structure.\n\nDescription\n\nThis function removes a jet from the tiling structure. It adjusts the linked list to be consistent with the removal of the jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.tiledjet_set_jetinfo!-Tuple{JetReconstruction.TiledJet, ClusterSequence, JetReconstruction.Tiling, Any, Any, Any}","page":"Internal API","title":"JetReconstruction.tiledjet_set_jetinfo!","text":"tiledjet_set_jetinfo!(jet::TiledJet, clusterseq::ClusterSequence, tiling::Tiling, jets_index, R2, p)\n\nInitialise a tiled jet from a PseudoJet (using an index into our ClusterSequence)\n\nArguments:\n\njet::TiledJet: The TiledJet object to set the information for.\nclusterseq::ClusterSequence: The ClusterSequence object containing the jets.\ntiling::Tiling: The Tiling object containing the tile information.\njets_index: The index of the jet in the ClusterSequence.\nR2: The jet radius parameter squared.\np: The power to raise the pt2 value to.\n\nThis function sets the eta, phi, kt2, jetsindex, NNdist, NN, tile_index, previous, and next fields of the TiledJet object.\n\nReturns:\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.upd_nn_crosscheck!-Tuple{Int64, Int64, Int64, Vararg{Any, 5}}","page":"Internal API","title":"JetReconstruction.upd_nn_crosscheck!","text":"upd_nn_crosscheck!(i, from, to, rapidity_array, phi_array, R2, nndist, nn)\n\nUpdate the nearest neighbor information for a given particle index i against all particles in the range indexes from to to. The function updates the nndist and nn arrays with the nearest neighbor distance and index respectively, both for particle i and the checked particles [from:to] (hence crosscheck).\n\nArguments\n\ni::Int: The index of the particle to update and check against.\nfrom::Int: The starting index of the range of particles to check against.\nto::Int: The ending index of the range of particles to check against.\nrapidity_array: An array containing the rapidity values of all particles.\nphi_array: An array containing the phi values of the all particles.\nR2: The squared jet distance threshold for considering a particle as a neighbour.\nnndist: The array that stores the nearest neighbor distances.\nnn: The array that stores the nearest neighbor indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.upd_nn_nocross!-Tuple{Int64, Int64, Int64, Vararg{Any, 5}}","page":"Internal API","title":"JetReconstruction.upd_nn_nocross!","text":"upd_nn_nocross!(i, from, to, rapidity_array, phi_array, R2, nndist, nn)\n\nUpdate the nearest neighbor information for a given particle index i against all particles in the range indexes from to to. The function updates the nndist and nn arrays with the nearest neighbor distance and index respectively, only for particle i (hence nocross).\n\nArguments\n\ni::Int: The index of the particle to update and check against.\nfrom::Int: The starting index of the range of particles to check against.\nto::Int: The ending index of the range of particles to check against.\nrapidity_array: An array containing the rapidity values of all particles.\nphi_array: An array containing the phi values of the all particles.\nR2: The squared jet distance threshold for considering a particle as a neighbour.\nnndist: The array that stores the nearest neighbor distances.\nnn: The array that stores the nearest neighbor indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.upd_nn_step!-NTuple{12, Any}","page":"Internal API","title":"JetReconstruction.upd_nn_step!","text":"upd_nn_step!(i, j, k, N, Nn, kt2_array, rapidity_array, phi_array, R2, nndist, nn, nndij)\n\nUpdate the nearest neighbor information after a jet merge step.\n\nArguments:\n\ni: Index of the first particle in the last merge step.\nj: Index of the second particle in the last merge step.\nk: Index of the current particle for which the nearest neighbour will be updated.\nN: Total number of particles (currently valid array indexes are [1:N]).\nNn: Number of nearest neighbors to consider.\nkt2_array: Array of transverse momentum squared values.\nrapidity_array: Array of rapidity values.\nphi_array: Array of azimuthal angle values.\nR2: Distance threshold squared for nearest neighbors.\nnndist: Array of nearest neighbor geometric distances.\nnn: Array of nearest neighbor indices.\nnndij: Array of metric distances between particles.\n\nThis function updates the nearest neighbor information for the current particle k by considering the distances to particles i and j. It checks if the distance between k and i is smaller than the current nearest neighbor distance for k, and updates the nearest neighbor information accordingly. It also updates the nearest neighbor information for i if the distance between k and i is smaller than the current nearest neighbor distance for i. Finally, it checks if the nearest neighbor of k is the total number of particles Nn and updates it to j if necessary.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.η","page":"Internal API","title":"JetReconstruction.η","text":"const η = eta\n\nAlias for the pseudorapidity function, eta.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.FourMomentum","text":"abstract type FourMomentum end\n\nInterface for composite types that includes fields px, py, py, and E that represents the components of a four-momentum vector. All concrete jets that are used in the package are subtypes of this type.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.HistoryElement","page":"Internal API","title":"JetReconstruction.HistoryElement","text":"struct HistoryElement\n\nA struct holding a record of jet mergers and finalisations\n\nFields:\n\nparent1: Index in history where first parent of this jet was created (NonexistentParent if this jet is an original particle)\nparent2: Index in history where second parent of this jet was created (NonexistentParent if this jet is an original particle); BeamJet if this history entry just labels the fact that the jet has recombined with the beam)\nchild: Index in history where the current jet is recombined with another jet to form its child. It is Invalid if this jet does not further recombine.\njetp_index: Index in the jets vector where we will find the PseudoJet object corresponding to this jet (i.e. the jet created at this entry of the history). NB: if this element of the history corresponds to a beam recombination, then jetp_index=Invalid.\ndij: The distance corresponding to the recombination at this stage of the clustering.\nmax_dij_so_far: The largest recombination distance seen so far in the clustering history.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.HistoryElement-Tuple{Any}","page":"Internal API","title":"JetReconstruction.HistoryElement","text":"HistoryElement(jetp_index)\n\nConstructs a HistoryElement object with the given jetp_index, used for initialising the history with original particles.\n\nArguments\n\njetp_index: The index of the jetp.\n\nReturns\n\nA HistoryElement object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.JetWithAncestors","page":"Internal API","title":"JetReconstruction.JetWithAncestors","text":"struct JetWithAncestors{T <: FourMomentum}\n\nA struct representing a jet with its origin ancestors.\n\nFields\n\nself::T: The jet object itself.\njetp_index::Int: The index of the jet in the corresponding cluster sequence.\nancestors::Set{Int}: A set of indices representing the jetp_indexes of ancestors of the jet (in the cluster sequence).\njet_rank::Int: The rank of the jet based on a comparison of all of the jet's ancestors\n\nNote\n\nThis structure needs its associated cluster sequence origin to be useful.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.Surrounding","page":"Internal API","title":"JetReconstruction.Surrounding","text":"struct Surrounding{N}\n\nStructure used for iterating over neighbour tiles.\n\nFields\n\nindices::NTuple{N, Int}: A tuple of N integers representing the indices.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.TiledJet","page":"Internal API","title":"JetReconstruction.TiledJet","text":"mutable struct TiledJet\n\nTiledJet represents a jet in a tiled algorithm for jet reconstruction, with additional information to track the jet's position in the tiled structures.\n\nFields\n\nid::Int: The ID of the jet.\neta::Float64: The rapidity of the jet.\nphi::Float64: The azimuthal angle of the jet.\nkt2::Float64: The transverse momentum squared of the jet.\nNN_dist::Float64: The distance to the nearest neighbor.\njets_index::Int: The index of the jet in the jet array.\ntile_index::Int: The index of the tile in the tile array.\ndij_posn::Int: The position of this jet in the dij compact array.\nNN::TiledJet: The nearest neighbor.\nprevious::TiledJet: The previous jet.\nnext::TiledJet: The next jet.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.TiledJet-Tuple{Any}","page":"Internal API","title":"JetReconstruction.TiledJet","text":"TiledJet(id)\n\nConstructs a TiledJet object with the given id and initializes its properties to zero.\n\nArguments\n\nid: The ID of the TiledJet object.\n\nReturns\n\nA TiledJet object with the specified id and values set to zero or noTiledJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.Tiling","page":"Internal API","title":"JetReconstruction.Tiling","text":"struct Tiling\n\nThe Tiling struct represents a tiling configuration for jet reconstruction.\n\nFields\n\nsetup::TilingDef: The tiling definition used for the configuration.\ntiles::Matrix{TiledJet}: A matrix of tiled jets, containing the first jet in each tile (then the linked list of the first jet is followed to get access to all jets in this tile).\npositions::Matrix{Int}: Used to track tiles that are on the edge of ϕ array, where neighbours need to be wrapped around.\ntags::Matrix{Bool}: The matrix of tags indicating whether a tile is valid or not (set to false initially, then true when the tile has been setup properly).\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.Tiling-Tuple{JetReconstruction.TilingDef}","page":"Internal API","title":"JetReconstruction.Tiling","text":"Tiling(setup::TilingDef)\n\nConstructs a initial Tiling object based on the provided setup parameters.\n\nArguments\n\nsetup::TilingDef: The setup parameters for the tiling.\n\nReturns\n\nA Tiling object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.TilingDef","page":"Internal API","title":"JetReconstruction.TilingDef","text":"struct TilingDef\n\nA struct representing the definition of a specific tiling scheme.\n\nFields\n\n_tiles_eta_min::Float64: The minimum rapidity of the tiles.\n_tiles_eta_max::Float64: The maximum rapidity of the tiles.\n_tile_size_eta::Float64: The size of a tile in rapidity (usually R^2).\n_tile_size_phi::Float64: The size of a tile in phi (usually a bit more than R^2).\n_n_tiles_eta::Int: The number of tiles across rapidity.\n_n_tiles_phi::Int: The number of tiles across phi.\n_n_tiles::Int: The total number of tiles.\n_tiles_ieta_min::Int: The minimum rapidity tile index.\n_tiles_ieta_max::Int: The maximum rapidity tile index.\n\nConstructor\n\nTilingDef(_tiles_eta_min, _tiles_eta_max, _tile_size_eta, _tile_size_phi,\n\t_n_tiles_eta, _n_tiles_phi, _tiles_ieta_min, _tiles_ieta_max)\n\nConstructs a TilingDef object with the given parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.neighbour_tiles","page":"Internal API","title":"JetReconstruction.neighbour_tiles","text":"struct neighbour_tiles\n\nA struct representing the neighbouring tiles.\n\nA struct for iterating over all neighbour tiles for a given Cartesian tile index. These are the tiles above and to the right of the given tile (X=included, O=not included):\n\nXXX\nX.X\nXXX\n\nNote, rapidity coordinate must be in range, ϕ coordinate wraps\n\nFields\n\nn_η::Int: Number of η tiles\nn_ϕ::Int: Number of ϕ tiles\nstart_η::Int: Centre η tile coordinate\nstart_ϕ::Int: Centre ϕ tile coordinate\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.rightmost_tiles","page":"Internal API","title":"JetReconstruction.rightmost_tiles","text":"struct rightmost_tiles\n\nA struct for iterating over rightmost tiles for a given Cartesian tile index. These are the tiles above and to the right of the given tile (X=included, O=not included):\n\nXXX\nO.X\nOOO\n\nNote, rapidity coordinate must be in range, ϕ coordinate wraps\n\nFields\n\nn_η::Int: Number of η tiles\nn_ϕ::Int: Number of ϕ tiles\nstart_η::Int: Centre η tile coordinate\nstart_ϕ::Int: Centre ϕ tile coordinate\n\n\n\n\n\n","category":"type"},{"location":"helpers/#Jet-Helper-Functions","page":"Jet Helpers","title":"Jet Helper Functions","text":"","category":"section"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"These functions are provided as a convenient way to work with the results of jet reconstruction.","category":"page"},{"location":"helpers/#Jet-Pair-Helpers","page":"Jet Helpers","title":"Jet Pair Helpers","text":"","category":"section"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"pt_fraction","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"Returns the transverse momentum fraction in the softer of the two jets.","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"kt_scale","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"Returns the transverse momentum scale between two jets, the product of the smaller p_T and the angular separation in the the η-ϕ plane.","category":"page"},{"location":"helpers/#Conversion-Functions","page":"Jet Helpers","title":"Conversion Functions","text":"","category":"section"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"lorentzvector","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"Return a cartesian LorentzVector from a jet.","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"lorentzvector_cyl","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"Return a cylindrical LorentzVectorCyl from a jet.","category":"page"},{"location":"substructure/#Jet-Substructure","page":"Substructure","title":"Jet Substructure","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Jet substructure techniques provide powerful tools for analysing and refining the properties of jets. Below are some of the key jet substructure functions that are available.","category":"page"},{"location":"substructure/#Mass-Drop-Tagging","page":"Substructure","title":"Mass Drop Tagging","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"mass_drop(jet::PseudoJet, clusterseq::ClusterSequence{PseudoJet}; mu::Float64, y::Float64) -> PseudoJet","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The mass_drop function identifies subjets in a jet that pass the mass drop tagging condition. To use the mass_drop function:","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Apply the mass_drop function to the jet and its clustering sequence.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"tagger = (mu=0.67, y=0.09)\ntagged_jet = mass_drop(jet, clusterseq; tagger...)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"If the jet is tagged successfully, the function returns the identified subjet. Else it returns the invalid_pseudojet object.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"","category":"page"},{"location":"substructure/#Soft-Drop-Tagging","page":"Substructure","title":"Soft Drop Tagging","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"soft_drop(jet::PseudoJet, clusterseq::ClusterSequence{PseudoJet}: zcut::Real, beta::Real) -> PseudoJet","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The soft_drop function applies soft-drop grooming to remove soft, wide-angle radiation from jets. It reclusters the jet with a specified radius and clustering method, iteratively checking the soft-drop condition on subjets. To use the soft_drop function:","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Apply the soft_drop function to the jet and its clustering sequence.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"tagger = (zcut = 0.1, beta = 2.0)\ntagged_jet = soft_drop(jet, clusterseq; tagger...)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"By default, the reclustering radius is set to 1.0 which can be modified by the user as:","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"tagger = (zcut = 0.1, beta = 2.0, radius = 0.4)\ntagged_jet = soft_drop(jet, clusterseq; tagger...)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"If the jet is tagged successfully, the function returns the identified subjet. Else it returns the invalid_pseudojet object.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"","category":"page"},{"location":"substructure/#Jet-Filtering","page":"Substructure","title":"Jet Filtering","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"jet_filtering(jet::PseudoJet, clusterseq::ClusterSequence{PseudoJet}; radius::Real, hardest_jets::Integer) -> PseudoJet","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The jet_filtering function filters a jet to retain only the hardest subjets based on a specified radius and number. To use the function:","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Apply the jet_filtering function to refine the jet.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"filter = (radius=0.3, hardest_jets=3)\nfiltered_jet = jet_filtering(jet, clusterseq; filter...)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The function returns the filtered jet that retains only the most significant subjets, reducing noise.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"","category":"page"},{"location":"substructure/#Jet-Trimming","page":"Substructure","title":"Jet Trimming","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"jet_trimming(jet::PseudoJet, clusterseq::ClusterSequence{PseudoJet}; radius::Real, fraction::Real, recluster_method::JetAlgorithm.Algorithm) -> PseudoJet","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The jet_trimming function trims a jet by removing subjets with transverse momentum below a specified fraction of the main jet's momentum. This method cleans up jets by removing soft particles. To use this function:","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Apply the jet_trimming function to clean the jet.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"trim = (radius=0.3, fraction=0.3, recluster_method=JetAlgorithm.CA)\ntrimmed_jet = jet_trimming(jet, clusterseq; trim...)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The function returns the trimmed jet if trimming is successful, or the invalid_pseudojet object.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"It is to be noted that the jet_trimming function reclusters the constituents of the jet using either C/A or kT algorithm, which needs to be specified.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"For a more detailed guide to use these substructure modules, one can refer to the provided examples in the examples/substructure directory.","category":"page"},{"location":"strategy/#Algorithm-Strategy","page":"Reconstruction Strategies","title":"Algorithm Strategy","text":"","category":"section"},{"location":"strategy/","page":"Reconstruction Strategies","title":"Reconstruction Strategies","text":"For the pp algorithms three strategies are available for the different algorithms, which can be specified by passing the named argument strategy=... to the reconstruction.","category":"page"},{"location":"strategy/","page":"Reconstruction Strategies","title":"Reconstruction Strategies","text":"Strategy Name Notes Interface\nRecoStrategy.Best Dynamically switch strategy based on input particle density jet_reconstruct\nRecoStrategy.N2Plain Global matching of particles at each interaction (works well for low N) plain_jet_reconstruct\nRecoStrategy.N2Tiled Use tiles of radius R to limit search space (works well for higher N) tiled_jet_reconstruct","category":"page"},{"location":"strategy/","page":"Reconstruction Strategies","title":"Reconstruction Strategies","text":"Generally one can use the jet_reconstruct interface, shown above, as the Best strategy safely as the overhead is extremely low. That interface supports a strategy option to switch to a different option.","category":"page"},{"location":"strategy/","page":"Reconstruction Strategies","title":"Reconstruction Strategies","text":"For e^+e^- algorithms particle densities are low, so the only implementation is of the same type as N2Plain.","category":"page"},{"location":"examples/#Jet-Reconstruction-Examples","page":"Examples","title":"Jet Reconstruction Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Jet Reconstruction package has a number of example files that show how to usage. These are in the examples subdirectory of the package and can be browsed directly on GitHub.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note: because of extra dependencies in these scripts, one must use the Project.toml file in the examples directory (or from examples/FEATURE where there is a further dependency, e.g., for visualisation).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following examples we assume that these are being run from the directory where the examples script is. Adjust the paths if you run from a different location.","category":"page"},{"location":"examples/#Standalone-Basic-Reconstruction-Examples","page":"Examples","title":"Standalone Basic Reconstruction Examples","text":"","category":"section"},{"location":"examples/#jetreco.jl","page":"Examples","title":"jetreco.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is a basic jet reconstruction example that shows how to call the package to perform a jet reconstruction, with different algorithms and (optionally) strategy, producing exclusive and inclusive jet selections.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia --project jetreco.jl --algorithm=AntiKt ../test/data/events.pp13TeV.hepmc3.zst\n...\njulia --project jetreco.jl --algorithm=Durham ../test/data/events.eeH.hepmc3.zst\n...\njulia --project jetreco.jl --maxevents=10 --strategy=N2Plain --algorithm=Kt --exclusive-njets=3 ../test/data/events.pp13TeV.hepmc3.zst\n...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are options to explicitly set the algorithm (use --help to see these).","category":"page"},{"location":"examples/#instrumented-jetreco.jl","page":"Examples","title":"instrumented-jetreco.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is a more sophisticated example that allows performance measurements to be made of the reconstruction, as well as profiling (flamegraphs and memory profiling). Use the --help option to see usage. e.g., to extract timing performance for the AntiKt algorithm using the tiled strategy:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia --project instrumented-jetreco.jl -S N2Tiled -A AntiKt --nsamples 100 ../test/data/events.pp13TeV.hepmc3.zst","category":"page"},{"location":"examples/#Visualisation","page":"Examples","title":"Visualisation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This subdirectory contains examples showing how to use built in support for visualising jets - either a final reconstruction state or an animation of the reconstruction process.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Particularly here the heavy Makie dependency is contained in the Project.toml file for these examples only.","category":"page"},{"location":"examples/#visualise-jets.jl","page":"Examples","title":"visualise-jets.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This script will produce a PNG/PDF showing the results of a jet reconstruction. This is a 3D plot where all the initial energy deposits are visualised, with colours that indicate in which final cluster the deposit ended up in.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia --project visualise-jets.jl -A AntiKt -R 1.0 ../../test/data/events.pp13TeV.hepmc3.zst test-pp.png","category":"page"},{"location":"examples/#visualise-jets.ipynb-and-visualise-jets-nb.ipynb","page":"Examples","title":"visualise-jets.ipynb and visualise-jets-nb.ipynb","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Similar to visualise-jets.jl these notebooks will produce a visualisation of jet reconstruction in the browser. This is a 3D plot where all the initial energy deposits are visualised, with colours that indicate in which final cluster the deposit ended up in.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first example is a Jupyter notebook, the second runs in Pluto.","category":"page"},{"location":"examples/#animate-reconstruction.jl","page":"Examples","title":"animate-reconstruction.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Performs jet reconstruction and then produces and animation of the process, showing how the jets merge from their different constituents.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia --project animate-reconstruction.jl -A AntiKt -R 1.0 ../../test/data/events.pp13TeV.hepmc3.zst test-pp.mp4","category":"page"},{"location":"examples/#EDM4hep","page":"Examples","title":"EDM4hep","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The examples/EDM4hep folder contains examples of using EDM4hep reconstructed particles as input to jet reconstruction. See the specific README.md file in that directory as well as EDM4hep Inputs.","category":"page"},{"location":"examples/#Jet-Constituents","page":"Examples","title":"Jet Constituents","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The examples/constituents folder shows an example of the two mechanisms to retrieve jet constituents.","category":"page"},{"location":"lundplane/#Lund-Jet-Plane","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"","category":"section"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"The Lund jet plane (arXiv:1807.04758) is a simple and intuitive way to visualize how a jet breaks up into smaller components. Each point in the plane represents a branching in the jet, helping understand how energy and angles are distributed within.","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"","category":"page"},{"location":"lundplane/#Decluster","page":"Lund Jet Plane","title":"Decluster","text":"","category":"section"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"decluster(jet::T, clusterseq::ClusterSequence{T}) where {T <: FourMomentum} -> Tuple{PseudoJet}","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"Recursively declusters a jet into two parent subjets using a provided clustering sequence. The subjets are ordered by decreasing transverse momentum squared (pt²).","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"j1, j2 = decluster(jet, clusterseq)","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"If no parents are found, the function returns nothing for one or both subjets.","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"Useful for building recursive jet trees and jet grooming algorithms.","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"","category":"page"},{"location":"lundplane/#Generate-Lund-Emissions","page":"Lund Jet Plane","title":"Generate Lund Emissions","text":"","category":"section"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"generate_lund_emissions(jet::PseudoJet, cs::ClusterSequence{PseudoJet}) -> Vector{NamedTuple}","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"Constructs the Lund plane emissions of a jet. The result is a list of declustering steps, each represented by a named tuple of physics observables.","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"lund_points = generate_lund_emissions(jet, cluster_seq)","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"Each named tuple includes:","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"h_pt: transverse momentum of the harder branch\ns_pt: transverse momentum of the softer branch\nz: momentum fraction\ndelta: angular distance ΔR\nkt: transverse momentum of the softer branch relative to the harder\npsi: azimuthal angle between the two splittings\nkappa: z × ΔR","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"These values are useful for visualization and physics analysis of jet splittings.","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"","category":"page"},{"location":"lundplane/#Visualisation-of-Lund-Jet-Plane","page":"Lund Jet Plane","title":"Visualisation of Lund Jet Plane","text":"","category":"section"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"examples/lundplane/lund-plane-visualisation.jl provides an example for generating and plotting the average lund image.","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"generate_average_lund_image(njets::Int, delta_array::Vector{Vector{Real}}, kt_array::Vector{Vector{Real}}; xrange::Tuple{Real}, yrange::Tuple{Real}, bins::Int) -> (xgrid, ygrid, avg_image)","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"Computes the average Lund image over a set of jets, by binning (log(1/ΔR), log(kt)) values from each jet into a 2D histogram and averaging the histograms per jet.","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"x, y, avg_image = generate_average_lund_image(njets, delta_array, kt_array; bins=25)","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"delta_array and kt_array should be arrays of arrays: one per jet.\nThe output is a tuple of x and y bin edges, and a 2D image array.\nThis is useful for creating heatmaps to compare jet substructure distributions.","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"","category":"page"},{"location":"lundplane/","page":"Lund Jet Plane","title":"Lund Jet Plane","text":"For further examples and advanced use cases, see the documentation in the examples/lundplane/ directory","category":"page"},{"location":"visualisation/#Jet-Visualisation-Documentation","page":"Visualisation","title":"Jet Visualisation Documentation","text":"","category":"section"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"Documentation for visualisation interfaces extension module.","category":"page"},{"location":"visualisation/#Plotting-and-Animation","page":"Visualisation","title":"Plotting and Animation","text":"","category":"section"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"(Image: illustration)","category":"page"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"To visualise the clustered jets as a 3d bar plot (see illustration above) Makie.jl is used. See the jetsplot function in ext/JetVisualisation.jl and its documentation for more. There are two worked examples in the examples directory of this package.","category":"page"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"The plotting code is a package extension and will load if the one of the Makie modules is loaded in the environment.","category":"page"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"The animatereco function will animate the reconstruction sequence, given a ClusterSequence object. See the function documentation below for the many options that can be customised.","category":"page"},{"location":"visualisation/#Function-Index","page":"Visualisation","title":"Function Index","text":"","category":"section"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"Pages = [\"visualisation.md\"]","category":"page"},{"location":"visualisation/#Jet-Visualisation-Public-Interfaces","page":"Visualisation","title":"Jet Visualisation Public Interfaces","text":"","category":"section"},{"location":"visualisation/#JetReconstruction.animatereco-Tuple{ClusterSequence, Any}","page":"Visualisation","title":"JetReconstruction.animatereco","text":"animatereco(cs::ClusterSequence, filename;\n            barsize_phi = 0.1,\n            barsize_y = 0.1,\n            colormap = :glasbey_category10_n256,\n            perspective = 0.5,\n            azimuth = 2.7,\n            elevation = 0.5,\n            framerate = 5,\n            ancestors = false,\n            Module = Makie)\n\nAnimate the jet reconstruction process and save it as a video file.\n\nArguments\n\ncs::ClusterSequence: The cluster sequence object containing the jets.\nfilename: The name of the output video file.\n\nOptional Arguments\n\nbarsize_phi=0.1: The size of the bars in the phi direction.\nbarsize_y=0.1: The size of the bars in the y direction.\ncolormap=:glasbey_category10_n256: The colormap to use for coloring the jets.\nperspective=0.5: The perspective of the plot.\nazimuth=2.7: The azimuth angle of the plot.\nelevation=0.5: The elevation angle of the plot.\nframerate=5: The framerate of the output video.\nend_frames=0: The number of static frames to show at the end of the animation. This can be useful to show the final state of the jets for a longer time.\ntitle=nothing: The title to add to the plot.\nancestors=false: Whether to include ancestors of the jets in the animation. When true the ancestors of the jets will be plotted as well, as height zero bars, with the same colour as the jet they are ancestors of.\nModule: The plotting module to use. Default is Makie.\n\nFor perspective, azimuth, and elevation, a single value can be passed for a fixed viewpoint, or a tuple of two values for a changing viewpoint. The viewpoint will then change linearly between the two values over the course of the animation.\n\nReturns\n\nfig: The figure object representing the final frame.\n\n\n\n\n\n","category":"method"},{"location":"visualisation/#JetReconstruction.jetsplot-Tuple{Any, Any}","page":"Visualisation","title":"JetReconstruction.jetsplot","text":"jetsplot(objects, idx_arrays; barsize_phi=0.1, barsize_eta=0.1, colormap=:glasbey_hv_n256, Module=Main)\n\nPlots a 3d bar chart that represents jets. Takes an objects array of objects to display and idx_arrays, an array of arrays with indices, where idx_arrays[i] gives indices of objects that form the jet number i. This function's signature might not be the most practical for the current version of the JetReconstruction.jl package, as it has been written during the early stage of development. There is now an overload of it that takes a ClusterSequence object as its argument.\n\nOptional arguments: barsize_phi::Real — width of a bar along the ϕ axis; barsize_eta::Real — width of a bar along the η axis; colormap::Symbol — Makie colour map; Module — the module where you have your Makie (see below);\n\n# example\nusing CairoMakie # use any other Makie that you have here\n\njetsplot([object1, object2, object3], [[1], [2, 3]])\n\nThe example above plots object1 as a separate jet in one colour and object2 and object3 together in another colour.\n\nThis function needs Makie.jl to work. You should install and import/use a specific backend yourself. jetsplot works with CairoMakie, WGLMakie, GLMakie, etc. Additionally, you can specify the module where you have your Makie explicitly:\n\nimport CairoMakie\njetsplot(my_objects, my_colour_arrays, Module=CairoMakie)\n\nimport GLMakie\njetsplot(my_objects, my_colour_arrays, Module=GLMakie)\n\nusing WGLMakie\njetsplot(my_objects, my_colour_arrays, Module=Main) #default\n\n\n\n\n\n","category":"method"},{"location":"visualisation/#JetReconstruction.jetsplot-Tuple{Any, ClusterSequence}","page":"Visualisation","title":"JetReconstruction.jetsplot","text":"jetsplot(objects, cs::ClusterSequence; barsize_phi=0.1, barsize_eta=0.1, colormap=:glasbey_hv_n256, Module=Main)\n\nPlots a 3d bar chart that represents jets. Takes objects, an array of objects to display (should be the same array you have passed to jet_reconstruct to get the cs::ClusterSequence), and the cs::ClusterSequence itself as arguments.\n\nOptional arguments: barsize_phi::Real — width of a bar along the ϕ axis; barsize_eta::Real — width of a bar along the η axis; colormap::Symbol — Makie colour map; Module — the module where you have your Makie (see below);\n\n# example\nusing CairoMakie # use any other Makie that you have here\njetsplot([object1, object2, object3], cluster_sequence_I_got_from_jet_reconstruct; Module=CairoMakie)\n\nThis function needs Makie.jl to work. You should install and import/use a specific backend yourself. jetsplot works with CairoMakie, WGLMakie, GLMakie, etc. Additionally, you can specify the module where you have your Makie explicitly:\n\nimport CairoMakie\njetsplot(my_objects, cs, Module=CairoMakie)\n\nimport GLMakie\njetsplot(my_objects, cs, Module=GLMakie)\n\nusing WGLMakie\njetsplot(my_objects, cs, Module=Main) #default\n\n\n\n\n\n","category":"method"},{"location":"#Jet-Reconstruction","page":"Home","title":"Jet Reconstruction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements sequential Jet Reconstruction (clustering) algorithms, which are used in high-energy physics as part of event reconstruction for pp and e^+e^- colliders.","category":"page"},{"location":"#Algorithms","page":"Home","title":"Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Algorithms used are based on the C++ FastJet package (https://fastjet.fr, hep-ph/0512210, arXiv:1111.6097), reimplemented natively in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The algorithms include anti-k_textT, Cambridge/Aachen, inclusive k_textT, generalised k_textT for pp events; and the Durham algorithm and generalised k_textT for e^+e^-.","category":"page"},{"location":"#Reconstruction-Interface","page":"Home","title":"Reconstruction Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main interface for reconstruction is jet_reconstruct, called as, e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"jet_reconstruct(particles; algorithm = JetAlgorithm.AntiKt, R = 1.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or with some of the optional arguments,","category":"page"},{"location":"","page":"Home","title":"Home","text":"jet_reconstruct(particles; algorithm = JetAlgorithm.GenKt, R = 0.4, \n                p = 0.5, recombine = addjets, strategy = RecoStrategy.Best)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where particles is a collection of 4-vector objects (see Input Particle Types) to reconstruct and the algorithm is given explicitly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the case of generalised k_T (for pp and e^+e^-) both the algorithm (GenKt, EEKt) and p are needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The R value determines the cone size; in the case of the Durham algorithm the R value is ignored.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a discussion of the recombine function, see Jet Recombination.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The object returned is a ClusterSequence, which internally tracks all merge steps and is used for Inclusive and Exclusive Selections.","category":"page"},{"location":"#Algorithm-Types","page":"Home","title":"Algorithm Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each known algorithm is referenced using a JetAlgorithm scoped enum value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Algorithm Type name Notes\nanti-k_textT JetAlgorithm.AntiKt Implies p=-1\nCambridge/Aachen JetAlgorithm.CA Implies p=0\ninclusive k_textT JetAlgorithm.Kt Implies p=1\ngeneralised k_textT JetAlgorithm.GenKt For pp, value of p must also be specified\ne^+e- k_textT / Durham JetAlgorithm.Durham R value ignored and can be omitted\ngeneralised e^+e- k_textT JetAlgorithm.EEKt For e^+e^-, value of p must also be specified","category":"page"},{"location":"#Strategy","page":"Home","title":"Strategy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generally one does not need to manually specify a strategy, but Algorithm Strategy describes how to do this, if desired.","category":"page"},{"location":"#Inclusive-and-Exclusive-Selections","page":"Home","title":"Inclusive and Exclusive Selections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To obtain final jets both inclusive (p_T cut) and exclusive (n_jets or d_ij cut) selections are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"inclusive_jets(clusterseq::ClusterSequence, ptmin = 0.0)\nexclusive_jets(clusterseq::ClusterSequence; dcut = nothing, njets = nothing)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(For exclusive_jets either dcut or njets is needed, but not both.)","category":"page"},{"location":"#Sorting","page":"Home","title":"Sorting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sorting vectors is trivial in Julia, no special sorting methods are provided. As an example, to sort exclusive jets of 50 (usually GeV, depending on your EDM) from highest energy to lowest:","category":"page"},{"location":"","page":"Home","title":"Home","text":"sorted_jets = sort!(inclusive_jets(cs::ClusterSequence; ptmin=5.0), \n  by=JetReconstruction.energy, rev=true)","category":"page"},{"location":"#Jet-Constituents-and-Jet-Parents","page":"Home","title":"Jet Constituents and Jet Parents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two ways to retrieve jet constituents. The first way is just to retrieve the indexes of the constituent jets. These indexes refer to the original collection of particles passed in to the reconstruction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"constituent_indexes","category":"page"},{"location":"","page":"Home","title":"Home","text":"The alternative it to retrieve the actual jets from the reconstruction sequence. In this case the returned array contains references to the jet objects (of type T) used internally in the reconstruction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"constituents","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that in both these cases the cluster sequence object from the reconstruction is required (to avoid circular dependencies and improve memory management reconstructed jets do not contain a link back to their cluster sequence).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To retrieve a jet's parents:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parent_jets","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will return a tuple of the target jet's parents, or nothing when one or both parents are missing (the only case when a jet has one parent is when it undergoes a beam merge step).","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Although it has been developed further since the CHEP2023 conference, the CHEP conference proceedings, 10.1051/epjconf/202429505017, should be cited if you use this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{refId0,\n    author = {{Stewart, Graeme Andrew} and {Gras, Philippe} and {Hegner, Benedikt} and {Krasnopolski, Atell}},\n    doi = {10.1051/epjconf/202429505017},\n    journal = {EPJ Web of Conf.},\n    pages = {05017},\n    title = {Polyglot Jet Finding},\n    url = {https://doi.org/10.1051/epjconf/202429505017},\n    volume = 295,\n    year = 2024,\n    eprint={2309.17309},\n    archivePrefix={arXiv},\n    primaryClass={hep-ex}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"The original paper on arXiv is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{stewart2023polyglot,\n      title={Polyglot Jet Finding}, \n      author={Graeme Andrew Stewart and Philippe Gras and Benedikt Hegner and Atell Krasnopolski},\n      year={2023},\n      eprint={2309.17309},\n      archivePrefix={arXiv},\n      primaryClass={hep-ex}\n}","category":"page"},{"location":"#Authors-and-Copyright","page":"Home","title":"Authors and Copyright","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Code in this package is authored by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Atell Krasnopolski <delta_atell@protonmail.com>\nGraeme A Stewart <graeme.andrew.stewart@cern.ch>\nPhilippe Gras <philippe.gras@cern.ch>","category":"page"},{"location":"","page":"Home","title":"Home","text":"and is Copyright 2022-2024 The Authors, CERN.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code is under the MIT License.","category":"page"}]
}
