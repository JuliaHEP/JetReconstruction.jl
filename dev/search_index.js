var documenterSearchIndex = {"docs":
[{"location":"lib/public/#Jet-Reconstruction-Public-Documentation","page":"Public API","title":"Jet Reconstruction Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Documentation for JetReconstruction.jl's public interfaces.","category":"page"},{"location":"lib/public/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Public-Methods-and-Types","page":"Public API","title":"Public Methods and Types","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Modules = [JetReconstruction]\nPrivate = false\nOrder = [:function, :type]","category":"page"},{"location":"lib/public/#JetReconstruction.constituent_indexes-Union{Tuple{T}, Tuple{T, ClusterSequence{T}}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.constituent_indexes","text":"constituent_indexes(jet::T, cs::ClusterSequence{T}) where T <: FourMomentum\n\nReturn the indexes of the original particles which are the constituents of the given jet.\n\nArguments\n\njet::T: The jet for which to retrieve the constituents.\ncs::ClusterSequence{T}: The cluster sequence object.\n\nReturns\n\nAn vector of indices representing the original constituents of the given jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.constituents-Union{Tuple{T}, Tuple{T, ClusterSequence{T}}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.constituents","text":"constituents(jet::T, cs::ClusterSequence{T}) where T <: FourMomentum\n\nGet the constituents of a given jet in a cluster sequence.\n\nArguments\n\ncs::ClusterSequence{T}: The cluster sequence object.\njet::T: The jet for which to retrieve the constituents.\n\nReturns\n\nAn array of jet objects (which are of the same type as the input jet) representing the constituents of the given jet,  \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.ee_genkt_algorithm-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Public API","title":"JetReconstruction.ee_genkt_algorithm","text":"ee_genkt_algorithm(particles::Vector{T}; p = -1, R = 4.0,\n                   algorithm::JetAlgorithm.Algorithm = JetAlgorithm.Durham,\n                   recombine = +) where {T}\n\nRun an e+e- reconstruction algorithm on a set of initial particles.\n\nArguments\n\nparticles::Vector{T}: A vector of particles to be clustered.\np = 1: The power parameter for the algorithm. Not required / ignored for the Durham algorithm when it is set to 1.\nR = 4.0: The jet radius parameter. Not required / ignored for the Durham algorithm.\nalgorithm::JetAlgorithm.Algorithm = JetAlgorithm.Durham: The specific jet algorithm to use.\nrecombine: The recombination scheme to use. Defaults to +.\n\nReturns\n\nThe result of the jet clustering as a ClusterSequence object.\n\nNotes\n\nThis is the public interface to the e+e- jet clustering algorithm. The function will check for consistency between the algorithm and the power parameter as needed. It will then prepare the internal EDM particles for the clustering itself, and call the actual reconstruction method _ee_genkt_algorithm.\n\nIf the algorithm is Durham, p is set to 1 and R is nominally set to 4.\n\nNote that unlike pp reconstruction the algorithm has to be specified explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.exclusive_jets-Union{Tuple{ClusterSequence{U}}, Tuple{U}} where U","page":"Public API","title":"JetReconstruction.exclusive_jets","text":"exclusive_jets(clusterseq::ClusterSequence{U}; dcut = nothing, njets = nothing, T = LorentzVectorCyl) where {U}\n\nReturn all exclusive jets of a ClusterSequence, with either a specific number of jets or a cut on the maximum distance parameter.\n\nArguments\n\nclusterseq::ClusterSequence: The ClusterSequence object containing the clustering history and jets.\ndcut::Union{Nothing, Real}: The distance parameter used to define the exclusive jets. If dcut is provided, the number of exclusive jets will be calculated based on this parameter.\nnjets::Union{Nothing, Integer}: The number of exclusive jets to be calculated. If njets is provided, the distance parameter dcut will be calculated based on this number.\nT = LorentzVectorCyl: The return type used for the selected jets.\n\nNote: Either dcut or njets must be provided (but not both).\n\nReturns\n\nAn array of T objects representing the exclusive jets.\n\nValid return types are LorentzVectorCyl and the jet type of the input clusterseq (U - either PseudoJet or EEjet depending which algorithm was used) (N.B. this will evolve in the future to be any subtype of FourMomentumBase; currently unrecognised types will return LorentzVectorCyl).\n\nExceptions\n\nArgumentError: If neither dcut nor njets is provided.\nArgumentError: If the algorithm used in the ClusterSequence object is not suitable for exclusive jets.\nErrorException: If the cluster sequence is incomplete and exclusive jets are unavailable.\n\nExamples\n\nexclusive_jets(clusterseq, dcut = 20.0)\nexclusive_jets(clusterseq, njets = 3, T = PseudoJet)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.final_jets","page":"Public API","title":"JetReconstruction.final_jets","text":"final_jets(jets::Vector{PseudoJet}, ptmin::AbstractFloat=0.0)\n\nThis function takes a vector of PseudoJet objects and a minimum transverse momentum ptmin as input. It returns a vector of FinalJet objects that satisfy the transverse momentum condition.\n\nArguments\n\njets::Vector{PseudoJet}: A vector of PseudoJet objects representing the input jets.\nptmin::AbstractFloat=0.0: The minimum transverse momentum required for a jet to be included in the final jets vector.\n\nReturns\n\nA vector of FinalJet objects that satisfy the transverse momentum condition.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#JetReconstruction.final_jets-2","page":"Public API","title":"JetReconstruction.final_jets","text":"Specialisation for final jets from LorentzVectorCyl (TODO: merge into more general function)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#JetReconstruction.final_jets-3","page":"Public API","title":"JetReconstruction.final_jets","text":"Specialisation for final jets from LorentzVectors (TODO: merge into more general function)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#JetReconstruction.inclusive_jets-Union{Tuple{ClusterSequence{U}}, Tuple{U}} where U","page":"Public API","title":"JetReconstruction.inclusive_jets","text":"inclusive_jets(clusterseq::ClusterSequence{U}; ptmin = 0.0, T = LorentzVectorCyl) where {U}\n\nReturn all inclusive jets of a ClusterSequence with pt > ptmin.\n\nArguments\n\nclusterseq::ClusterSequence: The ClusterSequence object containing the clustering history and jets.\nptmin::Float64 = 0.0: The minimum transverse momentum (pt) threshold for the inclusive jets.\nT = LorentzVectorCyl: The return type used for the selected jets.\n\nReturns\n\nAn array of T objects representing the inclusive jets.\n\nDescription\n\nThis function computes the inclusive jets from a given ClusterSequence object. It iterates over the clustering history and checks the transverse momentum of each parent jet. If the transverse momentum is greater than or equal to ptmin, the jet is added to the array of inclusive jets.\n\nValid return types are LorentzVectorCyl and the jet type of the input clusterseq (U - either PseudoJet or EEjet depending which algorithm was used) (N.B. this will evolve in the future to be any subtype of FourMomentumBase; currently unrecognised types will return LorentzVectorCyl).\n\nExample\n\ninclusive_jets(clusterseq; ptmin = 10.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.jet_filtering-Tuple{PseudoJet, ClusterSequence, JetFilter}","page":"Public API","title":"JetReconstruction.jet_filtering","text":"jet_filtering(jet, clusterseq, filter) -> PseudoJet\n\nFilters a jet to retain only the hardest subjets based on a specified radius and number.\n\nArguments:\n\njet::PseudoJet: PseudoJet instance representing the jet to filter.\nclusterseq::ClusterSequence: ClusterSequence containing jet history.\nfilter::JetFilter: Filter instance specifying radius and number of subjets.\n\nReturns:\n\nPseudoJet: Filtered jet composed of the hardest subjets.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.jet_reconstruct-Tuple{Any}","page":"Public API","title":"JetReconstruction.jet_reconstruct","text":"jet_reconstruct(particles; p::Union{Real, Nothing} = nothing,\n                     algorithm::Union{JetAlgorithm.Algorithm, Nothing} = nothing,\n                     R = 1.0, recombine = +,\n                     strategy::RecoStrategy.Strategy = RecoStrategy.Best)\n\nReconstructs jets from a collection of particles using a specified algorithm and strategy.\n\nArguments\n\nparticles: A collection of particles used for jet reconstruction. \np::Union{Real, Nothing} = nothing: The power value used for the distance measure for generalised k_T, which maps to a particular reconstruction algorithm (-1 = AntiKt, 0 = Cambridge/Aachen, 1 = Kt).\nalgorithm::Union{JetAlgorithm.Algorithm, Nothing} = nothing: The algorithm to use for jet reconstruction.\nR = 1.0: The jet radius parameter.\nrecombine = +: The recombination scheme used for combining particles.\nstrategy::RecoStrategy.Strategy = RecoStrategy.Best: The jet reconstruction  strategy to use. RecoStrategy.Best makes a dynamic decision based on the  number of starting particles.\n\nNote that one of p or algorithm must be specified, with algorithm preferred.\n\nReturns\n\nA cluster sequence object containing the reconstructed jets and the merging history.\n\nDetails\n\nparticles argument\n\nAny type that supplies the methods pt2(), phi(), rapidity(), px(), py(), pz(), energy() (in the JetReconstruction namespace) can be used. This includes LorentzVector, LorentzVectorCyl, and PseudoJet, for which these methods are already predefined in the JetReconstruction namespace.\n\nrecombine argument\n\nThe recombine argument is the function used to merge pairs of particles. The default is simply +(jet1,jet2), i.e. 4-momenta addition or the E-scheme.\n\nConsistency of p, algorithm and R arguments\n\nIf an algorithm is explicitly specified the p value should be consistent with it or nothing. If the algorithm is one where p can vary, then it has to be given, along with the algorithm.\n\nIf the p parameter is passed and algorithm=nothing, then pp-type reconstruction is implied (i.e., AntiKt, CA, Kt or GenKt will be used, depending on the value of p).\n\nWhen an algorithm has no R dependence the R parameter is ignored.\n\nExample\n\njet_reconstruct(particles; p = -1, R = 0.4)\njet_reconstruct(particles; algorithm = JetAlgorithm.Kt, R = 1.0)\njet_reconstruct(particles; algorithm = JetAlgorithm.Durham)\njet_reconstruct(particles; algorithm = JetAlgorithm.GenKt, p = 0.5, R = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.jet_trimming-Tuple{PseudoJet, ClusterSequence, JetTrim}","page":"Public API","title":"JetReconstruction.jet_trimming","text":"jet_trimming(jet, clusterseq, trim) -> PseudoJet\n\nTrims a jet by removing subjets with transverse momentum below a specified fraction.\n\nArguments:\n\njet::PseudoJet: PseudoJet instance representing the jet to trim.\nclusterseq::ClusterSequence: ClusterSequence containing jet history.\ntrim::JetTrim: Trim instance specifying trimming parameters.\n\nReturns:\n\nPseudoJet: Trimmed jet composed of retained subjets.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.kt_scale-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.kt_scale","text":"kt_scale(jet1::T, jet2::T) where {T <: FourMomentum}\n\nComputes the transverse momentum scale as the product of the minimum pt and  the angular separation in the η-ϕ plane (using pseudorapidity).\n\nReturns\n\nThe transverse momentum scale of the two jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.loadjets!-Tuple{Any, Any}","page":"Public API","title":"JetReconstruction.loadjets!","text":"loadjets!(filename, jets; splitby=isspace, constructor=(px,py,pz,E)->LorentzVectorHEP(E,px,py,pz), dtype=Float64)\n\nLoads the jets from a file. Ignores lines that start with '#'. Each line gets processed in the following way: the line is split using split(line, splitby) or simply split(line) by default. Every value in this line is then converted to the dtype (which is Float64 by default). These values are then used as arguments for the constructor function which should produce individual jets. By default, the constructor constructs Lorentz vectors.\n\nEverything that was already in jets is not affected as we only use push! on it.\n\nExample\n\n# Load jets from two files into one array\njets = []\nloadjets!(\"myjets1.dat\", jets)\nloadjets!(\"myjets2.dat\", jets)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.loadjets-Tuple{Any}","page":"Public API","title":"JetReconstruction.loadjets","text":"loadjets(filename; splitby=isspace, constructor=(px,py,pz,E)->LorentzVectorHEP(E,px,py,pz), VT=LorentzVector)\n\nLoad jets from a file.\n\nArguments\n\nfilename: The name of the file to load jets from.\nsplitby: The delimiter used to split the data in the file. Default is isspace.\nconstructor: A function that constructs a VT object from the jet data. Default is (px,py,pz,E)->LorentzVector(E,px,py,pz).\nVT: The type of the vector used to store the jet data. Default is LorentzVector.\n\nReturns\n\nA vector of VT objects representing the loaded jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.lorentzvector-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.lorentzvector","text":"lorentzvector(jet::T) where {T <: FourMomentum} ->  -> LorentzVector\n\nReturn a cartesian LorentzVector from a jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.lorentzvector_cyl-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.lorentzvector_cyl","text":"lorentzvector_cyl(jet::T) where T <: FourMomentum -> LorentzVectorHEP.LorentzVectorCyl\n\nReturn a cylindrical LorentzVectorCyl from a jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.mass_drop-Tuple{PseudoJet, ClusterSequence, MassDropTagger}","page":"Public API","title":"JetReconstruction.mass_drop","text":"mass_drop(jet, clusterseq, tag) -> PseudoJet\n\nIdentifies subjets in a jet that pass the mass drop tagging condition. The method stops at the first jet satisfying the mass and distance thresholds.\n\nArguments:\n\njet::PseudoJet: PseudoJet instance representing the jet to tag.\nclusterseq::ClusterSequence: ClusterSequence with jet clustering history.\ntag::MassDropTagger: MassDropTagger instance providing mass drop parameters.\n\nReturns:\n\nPseudoJet: The jet (or subjet) satisfying the mass drop conditions, if tagging is successful, otherwise a zero-momentum PseudoJet\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.n_exclusive_jets-Tuple{ClusterSequence}","page":"Public API","title":"JetReconstruction.n_exclusive_jets","text":"n_exclusive_jets(clusterseq::ClusterSequence; dcut::AbstractFloat)\n\nReturn the number of exclusive jets of a ClusterSequence that are above a certain dcut value.\n\nArguments\n\nclusterseq::ClusterSequence: The ClusterSequence object containing the clustering history.\ndcut::AbstractFloat: The maximum value for the distance parameter in the reconstruction.\n\nReturns\n\nThe number of exclusive jets in the ClusterSequence object.\n\nExample\n\nn_exclusive_jets(clusterseq, dcut = 20.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.parent_jets-Union{Tuple{T}, Tuple{T, ClusterSequence{T}}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.parent_jets","text":"parent_jets(jet::T, cs::ClusterSequence{T})::Tuple{Union{Nothing, T}, Union{Nothing, T}} where {T <: FourMomentum}\n\nFind the parent jets of a given jet in a cluster sequence.\n\nArguments\n\njet::T: The jet for which to find the parent jets.\ncs::ClusterSequence: The cluster sequence object.\n\nReturns\n\nA tuple of two elements, each of which is either the parent jet object or nothing (if the jet has no parent).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.plain_jet_reconstruct-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Public API","title":"JetReconstruction.plain_jet_reconstruct","text":"plain_jet_reconstruct(particles::Vector{T}; p::Union{Real, Nothing} = -1,\n                           algorithm::Union{JetAlgorithm.Algorithm, Nothing} = nothing,\n                           R = 1.0, recombine = +) where {T}\n\nPerform pp jet reconstruction using the plain algorithm.\n\nArguments\n\nparticles::Vector{T}: A vector of particles used for jet reconstruction, any  array of particles, which supports suitable 4-vector methods, viz. pt2(),  phi(), rapidity(), px(), py(), pz(), energy(), can be used. for each element.\np::Union{Real, Nothing} = -1: The power value used for jet reconstruction.\nalgorithm::Union{JetAlgorithm, Nothing} = nothing: The explicit jet algorithm to use.\nR::Float64 = 1.0: The radius parameter used for jet reconstruction.\nrecombine::Function = +: The recombination function used for jet reconstruction.\n\nNote for the particles argument, the 4-vector methods need to exist in the JetReconstruction package namespace.\n\nThis code will use the k_t algorithm types, operating in (rapidity, φ) space.\n\nIt is not necessary to specify both the algorithm and the p (power) value. If both are given they must be consistent or an exception is thrown.\n\nReturns\n\nVector{PseudoJet}: A vector of reconstructed jets.\n\nExample\n\njets = plain_jet_reconstruct(particles; p = -1, R = 0.4)\njets = plain_jet_reconstruct(particles; algorithm = JetAlgorithm.Kt, R = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.pt_fraction-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.pt_fraction","text":"pt_fraction(jet1::T, jet2::T) where T <: FourMomentum\n\nComputes the transverse momentum fraction of the softer of two jets.\n\nReturns\n\nThe transverse momentum fraction of the softer of the two jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.read_final_state_particles-Tuple{Any}","page":"Public API","title":"JetReconstruction.read_final_state_particles","text":"read_final_state_particles(fname; maxevents = -1, skipevents = 0, T=PseudoJet)\n\nReads final state particles from a file and returns them as a vector of type T.\n\nArguments\n\nfname: The name of the HepMC3 ASCII file to read particles from. If the file is gzipped, the function will automatically decompress it.\nmaxevents=-1: The maximum number of events to read. -1 means all events will be read.\nskipevents=0: The number of events to skip before an event is included.\nT=PseudoJet: The type of object to construct and return.\n\nReturns\n\nA vector of vectors of T objects, where each inner vector represents all the particles of a particular event. In particular T can be PseudoJet or a LorentzVector type. Note, if T is not PseudoJet, the order of the arguments in the constructor must be (t, x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.savejets-Tuple{Any, Any}","page":"Public API","title":"JetReconstruction.savejets","text":"savejets(filename, jets; format=\"px py pz E\")\n\nSave jet data to a file.\n\nArguments\n\nfilename: The name of the file to save the jet data to.\njets: An array of jet objects to save.\nformat=\"px py pz E\": (optional) A string specifying the format of the jet data to save. The default format is \"px py pz E\".\n\nDetails\n\nThis function saves jet data to a file in a specific format. Each line in the file represents a jet and contains the information about the jet in the specified format. The format string can include the following placeholders:\n\n\"E\" or \"energy\": Jet energy\n\"px\": Momentum along the x-axis\n\"py\": Momentum along the y-axis\n\"pz\": Momentum along the z-axis\n\"pt2\": Square of the transverse momentum\n\"phi\": Azimuth angle\n\"rapidity\": Rapidity\n\nLines starting with '#' are treated as comments and are ignored.\n\nIt is strongly NOT recommended to put something other than values and (possibly custom) separators in the format string.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.soft_drop-Tuple{PseudoJet, ClusterSequence, SoftDropTagger}","page":"Public API","title":"JetReconstruction.soft_drop","text":"soft_drop(jet, clusterseq, tag) -> PseudoJet\n\nApplies soft-drop grooming to remove soft, wide-angle radiation from jets. This function reclusters the jet and iteratively checks the soft-drop condition on subjets.\n\nArguments:\n\njet::PseudoJet: PseudoJet instance to groom.\nclusterseq::ClusterSequence: ClusterSequence containing jet history.\ntag::SoftDropTagger: SoftDropTagger instance with soft-drop parameters.\n\nReturns:\n\nPseudoJet: Groomed jet or zero-momentum PseudoJet if grooming fails.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.tiled_jet_reconstruct-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Public API","title":"JetReconstruction.tiled_jet_reconstruct","text":"tiled_jet_reconstruct(particles::Vector{T}; p::Union{Real, Nothing} = -1,\n                           algorithm::Union{JetAlgorithm.Algorithm, Nothing} = nothing,\n                           R = 1.0, recombine = +) where {T}\n\nMain jet reconstruction algorithm entry point for reconstructing jets using the tiled strategy for generic jet type T.\n\nNote - if a non-standard recombination is used, it must be defined for JetReconstruction.PseudoJet, as this struct is used internally.\n\nThis code will use the k_t algorithm types, operating in (rapidity, φ) space.\n\nIt is not necessary to specify both the algorithm and the p (power) value. If both are given they must be consistent or an exception is thrown.\n\nArguments\n\nparticles::Vector{T}: A vector of particles used as input for jet reconstruction. T must support methods px, py, pz and energy (defined in the JetReconstruction namespace)\np::Union{Real, Nothing} = -1: The power parameter for the jet reconstruction algorithm, thus switching between different algorithms.\nalgorithm::Union{JetAlgorithm.Algorithm, Nothing} = nothing: The explicit jet algorithm to use.\nR::Float64 = 1.0: The jet radius parameter for the jet reconstruction algorithm.\nrecombine::Function = +: The recombination function used for combining pseudojets.\n\nReturns\n\nVector{PseudoJet}: A vector of reconstructed jets.\n\nExample\n\ntiled_jet_reconstruct(particles::Vector{LorentzVectorHEP}; p = -1, R = 0.4, recombine = +)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.ClusterSequence","page":"Public API","title":"JetReconstruction.ClusterSequence","text":"struct ClusterSequence\n\nA struct holding the full history of a jet clustering sequence, including the final jets.\n\nFields\n\nalgorithm::JetAlgorithm.Algorithm: The algorithm used for clustering.\nstrategy::RecoStrategy.Strategy: The strategy used for clustering.\npower::Float64: The power value used for the clustering algorithm (not that this value is always stored as a Float64 to be type stable)\nR::Float64: The R parameter used for the clustering algorithm.\njets::Vector{T}: The actual jets in the cluster sequence, which are of type T <: FourMomentum.\nn_initial_jets::Int: The initial number of particles used for exclusive jets.\nhistory::Vector{HistoryElement}: The branching history of the cluster sequence. Each stage in the history indicates where to look in the jets vector to get the physical PseudoJet.\nQtot::Any: The total energy of the event.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.ClusterSequence-Union{Tuple{T}, Tuple{JetReconstruction.JetAlgorithm.Algorithm, Real, Float64, JetReconstruction.RecoStrategy.Strategy, Vector{T}, Any, Any}} where T<:JetReconstruction.FourMomentum","page":"Public API","title":"JetReconstruction.ClusterSequence","text":"ClusterSequence(algorithm::JetAlgorithm.Algorithm, p::Real, R::Float64, strategy::RecoStrategy.Strategy, jets::T, history, Qtot) where T <: FourMomentum\n\nConstruct a ClusterSequence object.\n\nArguments\n\nalgorithm::JetAlgorithm.Algorithm: The algorithm used for clustering.\np::Real: The power value used for the clustering algorithm.\nR::Float64: The R parameter used for the clustering algorithm.\nstrategy::RecoStrategy.Strategy: The strategy used for clustering.\njets::Vector{T}: The jets in the cluster sequence, which are of T <: FourMomentum\nhistory::Vector{HistoryElement}: The branching history of the cluster sequence.\nQtot::Any: The total energy of the event.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.EEjet","page":"Public API","title":"JetReconstruction.EEjet","text":"mutable struct EEjet\n\nThe EEjet struct is a 4-momentum object used for the e+e jet reconstruction routines.\n\nFields\n\npx::Float64: The x-component of the jet momentum.\npy::Float64: The y-component of the jet momentum.\npz::Float64: The z-component of the jet momentum.\nE::Float64: The energy of the jet.\n_cluster_hist_index::Int: The index of the cluster histogram.\n_p2::Float64: The squared momentum of the jet.\n_inv_p::Float64: The inverse momentum of the jet.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.FinalJet","page":"Public API","title":"JetReconstruction.FinalJet","text":"struct FinalJet\n\nA struct representing the final properties of a jet, used for JSON serialisation.\n\nFields\n\nrap::Float64: The rapidity of the jet.\nphi::Float64: The azimuthal angle of the jet.\npt::Float64: The transverse momentum of the jet.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.FinalJets","page":"Public API","title":"JetReconstruction.FinalJets","text":"struct FinalJets\n\nA struct with the vector of all jets for a certain jet identifier, used for JSON serialisation.\n\nFields\n\njetid::Int64: The ID of the jet.\njets::Vector{FinalJet}: A vector of FinalJet objects representing the jets.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.JetFilter","page":"Public API","title":"JetReconstruction.JetFilter","text":"struct JetFilter\n\nFilters jets based on radius and number of hardest subjets, reducing contamination.\n\nFields:\n\nfilter_radius::Float64: Radius parameter to recluster subjets.\nnum_hardest_jets::Int64: Number of hardest jets to retain in the filtered result.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.JetTrim","page":"Public API","title":"JetReconstruction.JetTrim","text":"struct JetTrim\n\nTrims soft, large-angle components from jets based on fraction and radius.\n\nFields:\n\ntrim_radius::Float64: Radius used for reclustering in trimming.\ntrim_fraction::Float64: Minimum momentum fraction for retained subjets.\nrecluster_method::JetAlgorithm.Algorithm: Method identifier for reclustering.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.MassDropTagger","page":"Public API","title":"JetReconstruction.MassDropTagger","text":"struct MassDropTagger\n\nUsed for tagging jets that undergo mass drop, a common technique in jet substructure.\n\nFields:\n\nmu::Float64: Maximum allowed mass ratio for a jet to pass tagging.\ny::Float64: Minimum kT distance threshold for parent separation.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.PseudoJet","page":"Public API","title":"JetReconstruction.PseudoJet","text":"mutable struct PseudoJet <: FourMomentum\n\nThe PseudoJet struct represents a pseudojet, a four-momentum object used in jet reconstruction algorithms. Additional information for the link back into the history of the clustering is stored in the _cluster_hist_index field. There is caching of the more expensive calculations for rapidity and azimuthal angle.\n\nFields\n\npx::Float64: The x-component of the momentum.\npy::Float64: The y-component of the momentum.\npz::Float64: The z-component of the momentum.\nE::Float64: The energy component of the momentum.\n_cluster_hist_index::Int: The index of the cluster history.\n_pt2::Float64: The squared transverse momentum.\n_inv_pt2::Float64: The inverse squared transverse momentum.\n_rap::Float64: The rapidity.\n_phi::Float64: The azimuthal angle.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#JetReconstruction.PseudoJet-NTuple{4, Real}","page":"Public API","title":"JetReconstruction.PseudoJet","text":"PseudoJet(px::Real, py::Real, pz::Real, E::Real)\n\nConstructs a PseudoJet object with the given momentum components and energy.\n\nArguments\n\npx::Real: The x-component of the momentum.\npy::Real: The y-component of the momentum.\npz::Real: The z-component of the momentum.\nE::Real: The energy.\n\nReturns\n\nA PseudoJet object.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.PseudoJet-Tuple{Real, Real, Real, Real, Int64, Real}","page":"Public API","title":"JetReconstruction.PseudoJet","text":"PseudoJet(px::Real, py::Real, pz::Real, E::Real,\n    _cluster_hist_index::Int,\n    pt2::Real)\n\nConstructs a PseudoJet object with the given momentum components and energy and history index.\n\nArguments\n\npx::Real: The x-component of the momentum.\npy::Real: The y-component of the momentum.\npz::Real: The z-component of the momentum.\nE::Real: The energy.\n_cluster_hist_index::Int: The cluster history index.\npt2::Real: The transverse momentum squared.\n\nReturns\n\nA PseudoJet object.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#JetReconstruction.SoftDropTagger","page":"Public API","title":"JetReconstruction.SoftDropTagger","text":"struct SoftDropTagger\n\nApplies a soft-drop condition on jets, trimming away soft, wide-angle radiation.\n\nFields:\n\nzcut::Float64: Minimum allowed energy fraction for subjets.\nb::Float64: Angular exponent controlling soft radiation suppression.\ncluster_rad::Float64: The new radius that will be used to recluster the components of the jet, by default set to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"particles/#Input-Particle-Types","page":"Particle Inputs","title":"Input Particle Types","text":"","category":"section"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"For the particles input to the reconstruction any one dimensional AbstractArray{T, 1} can be used, where the type T has to implement methods to extract the 4-vector components, viz, the following are required:","category":"page"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"JetReconstuction.px(particle::T)\nJetReconstuction.py(particle::T)\nJetReconstuction.pz(particle::T)\nJetReconstuction.energy(particle::T)","category":"page"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"Currently built-in supported types are LorentzVectorHEP, the PseudoJet and EEjets from this package, and ReconstructedParticles from EDM4hep Inputs.","category":"page"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"If you require support for a different input collection type then ensure you define the px(), etc. methods for your specific type and in the JetReconstruction package. This use of what might be considered type piracy is blessed as long as you are en end user of the jet reconstruction package.","category":"page"},{"location":"particles/","page":"Particle Inputs","title":"Particle Inputs","text":"If your type is used in several places or by different users, please consider writing a package extension that will support your type, following the model for EDM4hep in ext/EDM4hepJets.jl.","category":"page"},{"location":"EDM4hep/#EDM4hep-Inputs","page":"EDM4hep","title":"EDM4hep Inputs","text":"","category":"section"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"Extension functionality to read EDM4hep ReconstructedParticles, using the EDM4hep.jl package.","category":"page"},{"location":"EDM4hep/#Examples","page":"EDM4hep","title":"Examples","text":"","category":"section"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"EDM4hep ReconstructedParticles can be used as direct input into jet reconstruction.","category":"page"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"A number of working examples are maintained in the EDM4hep examples directory of the package's examples.","category":"page"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"Here is a snippet that shows the main steps:","category":"page"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"using EDM4hep\nusing EDM4hep.RootIO\nusing JetReconstruction\n\n# Change this to something that works on your system\ninput_file = joinpath(\"directory\", \"EDM4hep.root\")\nreader = RootIO.Reader(input_file)\nevents = RootIO.get(reader, \"events\")\n\nevt = events[1]\n\nrecps = RootIO.get(reader, evt, \"ReconstructedParticles\")\n\ncs = jet_reconstruct(recps; algorithm = JetAlgorithm.Durham)","category":"page"},{"location":"EDM4hep/#Function-Index","page":"EDM4hep","title":"Function Index","text":"","category":"section"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"Pages = [\"EDM4hep.md\"]","category":"page"},{"location":"EDM4hep/#EDM4hep-Interfaces","page":"EDM4hep","title":"EDM4hep Interfaces","text":"","category":"section"},{"location":"EDM4hep/","page":"EDM4hep","title":"EDM4hep","text":"Modules = [EDM4hepJets]\nOrder = [:function]","category":"page"},{"location":"EDM4hep/#JetReconstruction.energy-Tuple{ReconstructedParticle}","page":"EDM4hep","title":"JetReconstruction.energy","text":"JetReconstruction.energy(recoparticle::ReconstructedParticle)\n\nReturn the energy component of a ReconstructedParticle's four vector.\n\n\n\n\n\n","category":"method"},{"location":"EDM4hep/#JetReconstruction.px-Tuple{ReconstructedParticle}","page":"EDM4hep","title":"JetReconstruction.px","text":"JetReconstruction.px(recoparticle::ReconstructedParticle)\n\nReturn the x component of the momentum of a ReconstructedParticle.\n\n\n\n\n\n","category":"method"},{"location":"EDM4hep/#JetReconstruction.py-Tuple{ReconstructedParticle}","page":"EDM4hep","title":"JetReconstruction.py","text":"JetReconstruction.py(recoparticle::ReconstructedParticle)\n\nReturn the y component of the momentum of a ReconstructedParticle.\n\n\n\n\n\n","category":"method"},{"location":"EDM4hep/#JetReconstruction.pz-Tuple{ReconstructedParticle}","page":"EDM4hep","title":"JetReconstruction.pz","text":"JetReconstruction.pz(recoparticle::ReconstructedParticle)\n\nReturn the z component of the momentum of a ReconstructedParticle.\n\n\n\n\n\n","category":"method"},{"location":"extras/serialisation/#Jet-Serialisation","page":"Serialisation","title":"Jet Serialisation","text":"","category":"section"},{"location":"extras/serialisation/","page":"Serialisation","title":"Serialisation","text":"The package provides methods such as loadjets, loadjets!, and savejets that one can use to save and load objects on/from disk easily in a very flexible format. See documentation for more.","category":"page"},{"location":"lib/internal/#Jet-Reconstruction-Internal-Documentation","page":"Internal API","title":"Jet Reconstruction Internal Documentation","text":"","category":"section"},{"location":"lib/internal/","page":"Internal API","title":"Internal API","text":"Documentation for JetReconstruction.jl's internal methods and types.","category":"page"},{"location":"lib/internal/","page":"Internal API","title":"Internal API","text":"N.B. no guarantee is made of stability of these interfaces or types.","category":"page"},{"location":"lib/internal/","page":"Internal API","title":"Internal API","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/internal/#Index","page":"Internal API","title":"Index","text":"","category":"section"},{"location":"lib/internal/","page":"Internal API","title":"Internal API","text":"Pages = [\"internal.md\"]","category":"page"},{"location":"lib/internal/#Internal-Methods-and-Types","page":"Internal API","title":"Internal Methods and Types","text":"","category":"section"},{"location":"lib/internal/","page":"Internal API","title":"Internal API","text":"Modules = [JetReconstruction]\nPublic = false\nOrder = [:function, :type]","category":"page"},{"location":"lib/internal/#Base.:+-Tuple{PseudoJet, PseudoJet}","page":"Internal API","title":"Base.:+","text":"+(j1::PseudoJet, j2::PseudoJet)\n\nAddition operator for PseudoJet objects.\n\nArguments\n\nj1::PseudoJet: The first PseudoJet object.\nj2::PseudoJet: The second PseudoJet object.\n\nReturns\n\nA new PseudoJet object with the sum of the momenta and energy of j1 and j2.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Base.copy-Tuple{JetReconstruction.TiledJet}","page":"Internal API","title":"Base.copy","text":"copy(j::TiledJet)\n\nCreate a copy of a TiledJet object.\n\nArguments\n\nj::TiledJet: The TiledJet object to be copied.\n\nReturns\n\nA new TiledJet object with the same attributes as the input object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Base.iterate","page":"Internal API","title":"Base.iterate","text":"Base.iterate(t::neighbour_tiles, state=1)\n\nIterate over the neighbour_tiles object, returning all the neighbour tiles for a given Cartesian tile index.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#Base.iterate-2","page":"Internal API","title":"Base.iterate","text":"Base.iterate(t::rightmost_tiles, state=1)\n\nIterate over the rightmost_tiles object, returning all the rightmost tiles for a given Cartesian tile index.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#Base.iterate-Tuple{JetReconstruction.TiledJet}","page":"Internal API","title":"Base.iterate","text":"Base.iterate(tj::TiledJet)\n\nIterate over a TiledJet object's linked list, walking over all jets until the end (then the next jet is invalid).\n\nArguments\n\ntj::TiledJet: The TiledJet object to start to iterate over.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#Base.show-Tuple{IO, PseudoJet}","page":"Internal API","title":"Base.show","text":"show(io::IO, jet::PseudoJet)\n\nPrint a PseudoJet object to the specified IO stream.\n\nArguments\n\nio::IO: The IO stream to which the information will be printed.\njet::PseudoJet: The PseudoJet object whose information will be printed.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.CosTheta-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.CosTheta","text":"CosTheta(jet::T) where {T <: FourMomentum}\n\nCompute the cosine of the angle between the momentum vector of jet and the z-axis.\n\nReturns\n\nThe cosine of the angle between the jet and the z-axis.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._ee_genkt_algorithm-Tuple{}","page":"Internal API","title":"JetReconstruction._ee_genkt_algorithm","text":"_ee_genkt_algorithm(; particles::Vector{EEjet}, p = 1, R = 4.0,\n                   algorithm::JetAlgorithm.Algorithm = JetAlgorithm.Durham,\n                   recombine = +)\n\nThis function is the actual implementation of the e+e- jet clustering algorithm.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._ensure_valid_rap_phi-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction._ensure_valid_rap_phi","text":"_ensure_valid_rap_phi(p::PseudoJet)\n\nEnsure that the rapidity and azimuthal angle of the PseudoJet p are valid. If the azimuthal angle is invalid (used as a proxy for both variables), they are set to a valid value using _set_rap_phi!.\n\nArguments\n\np::PseudoJet: The PseudoJet object to ensure valid rapidity and azimuthal angle for.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._plain_jet_reconstruct-Tuple{}","page":"Internal API","title":"JetReconstruction._plain_jet_reconstruct","text":"_plain_jet_reconstruct(; particles::Vector{PseudoJet}, p = -1, \n                            algorithm::JetAlgorithm.Algorithm = JetAlgorithm.AntiKt,\n                            R = 1.0, recombine = +)\n\nThis is the internal implementation of jet reconstruction using the plain algorithm. It takes a vector of particles representing the input particles and reconstructs jets based on the specified parameters. Here the particles must be of type PseudoJet.\n\nUsers of the package should use the plain_jet_reconstruct function as their entry point to this jet reconstruction.\n\nThe power value maps to specific pp jet reconstruction algorithms: -1 = AntiKt, 0 = Cambridge/Aachen, 1 = Inclusive Kt. Floating point values are allowed for generalised k_t algorithm. The algorithm parameter must be consistent with the power parameter.\n\nArguments\n\nparticles: A vector of PseudoJet objects representing the input particles.\np = -1: The power to which the transverse momentum (pt) of each particle is raised.\nR = 1.0: The jet radius parameter.\nalgorithm::JetAlgorithm.Algorithm = JetAlgorithm.AntiKt: The jet reconstruction  algorithm to use.\nrecombine: The recombination function used to merge two jets. Default is + (additive recombination).\n\nReturns\n\nclusterseq: The resulting ClusterSequence object representing the reconstructed jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._set_rap_phi!-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction._set_rap_phi!","text":"setrap_phi!(p::PseudoJet)\n\nSet the rapidity and azimuthal angle of the PseudoJet p.\n\nArguments\n\np::PseudoJet: The PseudoJet object for which to set the rapidity and azimuthal angle.\n\nDescription\n\nThis function calculates and sets the rapidity and azimuthal angle of the PseudoJet p based on its momentum components. The rapidity is calculated in a way that is insensitive to roundoff errors when the momentum components are large. If the PseudoJet represents a point with infinite rapidity, a large number is assigned to the rapidity in order to lift the degeneracy between different zero-pt momenta.\n\nNote - the ϕ angle is calculated in the range [0, 2π).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._tiled_jet_reconstruct-Tuple{Vector{PseudoJet}}","page":"Internal API","title":"JetReconstruction._tiled_jet_reconstruct","text":"_tiled_jet_reconstruct(particles::Vector{PseudoJet}; p::Real = -1,\n                            algorithm::JetAlgorithm.Algorithm = JetAlgorithm.AntiKt,\n                            R = 1.0, recombine = +)\n\nMain jet reconstruction algorithm entry point for reconstructing jets once preprocessing of data types are done. The algorithm parameter must be consistent with the power parameter.\n\nArguments\n\nparticles::Vector{PseudoJet}: A vector of PseudoJet particles used as input for jet reconstruction.\np::Real = -1: The power parameter for the jet reconstruction algorithm, thus switching between different algorithms.\nR = 1.0: The jet radius parameter for the jet reconstruction algorithm.\nalgorithm::JetAlgorithm.Algorithm = JetAlgorithm.AntiKt: The jet reconstruction  algorithm to use.\nrecombine::Function = +: The recombination function used for combining pseudojets.\n\nReturns\n\nVector{PseudoJet}: A vector of reconstructed jets.\n\nExample\n\ntiled_jet_reconstruct(particles::Vector{PseudoJet}; p = 1, R = 1.0, recombine = +)\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._tj_diJ-Tuple{Any}","page":"Internal API","title":"JetReconstruction._tj_diJ","text":"_tj_diJ(jet)\n\nCompute the dij metric value for a given jet.\n\nArguments\n\njet: The input jet.\n\nReturns\n\nThe dij value for the jet.\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction._tj_dist-Tuple{Any, Any}","page":"Internal API","title":"JetReconstruction._tj_dist","text":"_tj_dist(jetA, jetB)\n\nCompute the geometric distance in the (y, ϕ)-plane between two jets in the TiledAlgoLL module.\n\nArguments\n\njetA: The first jet.\njetB: The second jet.\n\nReturns\n\nThe squared distance between jetA and jetB.\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.add_step_to_history!-Tuple{ClusterSequence, Vararg{Any, 4}}","page":"Internal API","title":"JetReconstruction.add_step_to_history!","text":"add_step_to_history!(clusterseq::ClusterSequence, parent1, parent2, jetp_index, dij)\n\nAdd a new jet's history into the recombination sequence.\n\nArguments:\n\nclusterseq::ClusterSequence: The cluster sequence object.\nparent1: The index of the first parent.\nparent2: The index of the second parent.\njetp_index: The index of the jet.\ndij: The dij value.\n\nThis function adds a new HistoryElement to the history vector of the clusterseq object. The HistoryElement contains information about the parents, child, jet index, dij value, and the maximum dij value so far. It also updates the child index of the parent elements.\n\nIf the parent1 or parent2 have already been recombined, an InternalError is thrown. The jetp_index is used to update the _cluster_hist_index of the corresponding PseudoJet object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.add_untagged_neighbours_to_tile_union-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.add_untagged_neighbours_to_tile_union","text":"add_untagged_neighbours_to_tile_union(center_index, tile_union, n_near_tiles, tiling)\n\nAdds to the vector tileunion the tiles that are in the neighbourhood of the specified centerindex, including itself and whose tagged status are false - start adding from position nneartiles-1, and increase nneartiles. When a neighbour is added its tagged status is set to true.\n\nArguments\n\ncenter_index: The index of the center tile.\ntile_union: An array to store the indices of neighbouring tiles.\nn_near_tiles: The number of neighbouring tiles.\ntiling: The tiling object containing the tile tags.\n\nReturns\n\nThe updated number of near tiles.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.angular_distance-Tuple{Any, Any, Any}","page":"Internal API","title":"JetReconstruction.angular_distance","text":"angular_distance(eereco, i, j) -> Float64\n\nCalculate the angular distance between two jets i and j using the formula 1 - cos(θ_ij).\n\nArguments\n\neereco: The array of EERecoJet objects.\ni: The first jet.\nj: The second jet.\n\nReturns\n\nFloat64: The angular distance between i and j, which is 1 - cos\theta.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.check_algorithm_power_consistency-Tuple{}","page":"Internal API","title":"JetReconstruction.check_algorithm_power_consistency","text":"Allow a check for algorithm and power consistency\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.copy_to_slot!-Tuple{Any, Any, Any}","page":"Internal API","title":"JetReconstruction.copy_to_slot!","text":"copy_to_slot!(eereco, i, j)\n\nCopy the contents of slot i in the eereco array to slot j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.deltaR-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.deltaR","text":"deltaR(jet1::T, jet2::T) where T <: FourMomentum\n\nFunction to calculate the distance in the y-ϕ plane between two jets jet1 and jet2 (that is using rapidity and azimuthal angle).\n\nReturns\n\nThe Euclidean distance in the y-ϕ plane for the two jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.deltar-Union{Tuple{T}, Tuple{T, T}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.deltar","text":"deltar(jet1::T, jet2::T) where T <: FourMomentum\n\nFunction to calculate the distance in the η-ϕ plane between two jets jet1 and jet2 (that is, using the pseudorapidity and azimuthal angle).\n\nReturns\n\nThe Euclidean distance in the η-ϕ plane for the two jets.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.detach!-Tuple{JetReconstruction.TiledJet}","page":"Internal API","title":"JetReconstruction.detach!","text":"detach!(jet::TiledJet)\n\nDetach a TiledJet from its linked list by updating the previous and next pointers.\n\nArguments\n\njet::TiledJet: The TiledJet object to detach.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.determine_rapidity_extent-Union{Tuple{Vector{T}}, Tuple{T}} where T<:AbstractFloat","page":"Internal API","title":"JetReconstruction.determine_rapidity_extent","text":"determine_rapidity_extent(eta::Vector{T}) where T <: AbstractFloat\n\nCalculate the minimum and maximum rapidities based on the input vector eta. The function determines the rapidity extent by binning the multiplicities as a function of rapidity and finding the minimum and maximum rapidities such that the edge bins contain a certain fraction (~1/4) of the busiest bin and a minimum number of particles.\n\nThis is the heuristic which is used by FastJet (inline comments are from FastJet).\n\nArguments\n\neta::Vector{T}: A vector of rapidity values.\n\nReturns\n\nminrap::T: The minimum rapidity value.\nmaxrap::T: The maximum rapidity value.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.dij-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.dij","text":"dij(i, kt2_array, nn, nndist)\n\nCompute the dij value for a given index i to its nearest neighbor. The nearest neighbor is determined from nn[i], and the metric distance to the nearest neighbor is given by the distance nndist[i] applying the lower of the kt2_array values for the two particles.ßß\n\nArguments\n\ni: The index of the element.\nkt2_array: An array of kt2 values.\nnn: An array of nearest neighbors.\nnndist: An array of nearest neighbor distances.\n\nReturns\n\nThe computed dij value.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.dij_dist-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.dij_dist","text":"dij_dist(eereco, i, j, dij_factor)\n\nCalculate the dij distance between two e^+e^-jets.\n\nArguments\n\neereco: The array of EERecoJet objects.\ni: The first jet.\nj: The second jet.\ndij_factor: The scaling factor to multiply the dij distance by.\n\nReturns\n\nThe dij distance between i and j.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.dist-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.dist","text":"dist(i, j, rapidity_array, phi_array)\n\nCompute the distance between points in a 2D space defined by rapidity and phi coordinates.\n\nArguments\n\ni::Int: Index of the first point to consider (indexes into rapidity_array and phi_array).\nj::Int: Index of the second point to consider (indexes into rapidity_array and phi_array).\nrapidity_array::Vector{Float64}: Array of rapidity coordinates.\nphi_array::Vector{Float64}: Array of phi coordinates.\n\nReturns\n\ndistance::Float64: The distance between the two points.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.do_iB_recombination_step!-Tuple{ClusterSequence, Any, Any}","page":"Internal API","title":"JetReconstruction.do_iB_recombination_step!","text":"do_iB_recombination_step!(clusterseq::ClusterSequence, jet_i, diB)\n\nBookkeeping for recombining a jet with the beam (i.e., finalising the jet) by adding a step to the history of the cluster sequence.\n\nArguments\n\nclusterseq::ClusterSequence: The cluster sequence object.\njet_i: The index of the jet.\ndiB: The diB value.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.do_ij_recombination_step!","page":"Internal API","title":"JetReconstruction.do_ij_recombination_step!","text":"do_ij_recombination_step!(clusterseq::ClusterSequence, jet_i, jet_j, dij, recombine=+)\n\nPerform the bookkeeping associated with the step of recombining jeti and jetj (assuming a distance dij).\n\nArguments\n\nclusterseq::ClusterSequence: The cluster sequence object.\njet_i: The index of the first jet to be recombined.\njet_j: The index of the second jet to be recombined.\ndij: The distance between the two jets.\nrecombine=+: The recombination function to be used. Default is addition.\n\nReturns\n\nnewjet_k: The index of the newly created jet.\n\nDescription\n\nThis function performs the i-j recombination step in the cluster sequence. It creates a new jet by recombining the first two jets using the specified recombination function. The new jet is then added to the cluster sequence. The function also updates the indices and history information of the new jet and sorts out the history.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#JetReconstruction.energy-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.energy","text":"energy(p::PseudoJet)\n\nReturn the energy of a PseudoJet.\n\nArguments\n\np::PseudoJet: The PseudoJet object.\n\nReturns\n\nThe energy of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.eta-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.eta","text":"eta(jet::T) where {T <: FourMomentum}\n\nCompute the pseudorapidity (η) of a jet.\n\nReturns\n\nThe pseudorapidity (η) of the jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.fast_findmin-Tuple{Any, Any}","page":"Internal API","title":"JetReconstruction.fast_findmin","text":"fast_findmin(dij, n)\n\nFind the minimum value and its index in the first n elements of the dij array. The use of @turbo macro gives a significant performance boost.\n\nArguments\n\ndij: An array of values.\nn: The number of elements to consider in the dij array.\n\nReturns\n\ndij_min: The minimum value in the first n elements of the dij array.\nbest: The index of the minimum value in the dij array.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.find_tile_neighbours!-NTuple{5, Any}","page":"Internal API","title":"JetReconstruction.find_tile_neighbours!","text":"find_tile_neighbours!(tile_union, jetA, jetB, oldB, tiling)\n\nFind the union of neighbouring tiles of jetA, jetB, and oldB and add them to the tile_union. This established the set of tiles over which searches for updated and new nearest-neighbours must be run\n\nArguments\n\ntile_union: The tile union to which the neighbouring tiles will be added.\njetA: The first jet.\njetB: The second jet.\noldB: The old second jet.\ntiling: The tiling information.\n\nReturns\n\nThe number of neighbouring tiles added to the tile_union.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.geometric_distance-NTuple{4, AbstractFloat}","page":"Internal API","title":"JetReconstruction.geometric_distance","text":"geometric_distance(eta1::AbstractFloat, phi1::AbstractFloat, eta2::AbstractFloat, phi2::AbstractFloat)\n\nCompute the geometric distance between two points in the rap-phi plane.\n\nArguments\n\neta1::AbstractFloat: The eta coordinate of the first point.\nphi1::AbstractFloat: The phi coordinate of the first point.\neta2::AbstractFloat: The eta coordinate of the second point.\nphi2::AbstractFloat: The phi coordinate of the second point.\n\nReturns\n\ndistance::Float64: The geometric distance between the two points.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_algorithm_power_consistency-Tuple{}","page":"Internal API","title":"JetReconstruction.get_algorithm_power_consistency","text":"get_algorithm_power_consistency(; p::Union{Real, Nothing}, algorithm::Union{JetAlgorithm.Algorithm, Nothing})\n\nGet the algorithm and power consistency correct\n\nThis function checks the consistency between the algorithm and power parameters. If the algorithm is specified, it checks if the power parameter is consistent with the algorithm's known power. If the power parameter is not specified, it sets the power parameter based on the algorithm. If neither the algorithm nor the power parameter is specified, it throws an ArgumentError.\n\nArguments\n\np::Union{Real, Nothing}: The power value.\nalgorithm::Union{JetAlgorithm.Algorithm, Nothing}: The algorithm.\n\nReturns\n\nA named tuple of the consistent power and algorithm values.\n\nThrows\n\nArgumentError: If the algorithm and power are inconsistent or if neither the algorithm nor the power is specified.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_all_ancestors-Tuple{Any, ClusterSequence}","page":"Internal API","title":"JetReconstruction.get_all_ancestors","text":"get_all_ancestors(idx, cs::ClusterSequence)\n\nRecursively finds all ancestors of a given index in a ClusterSequence object.\n\nArguments\n\nidx: The index of the jet for which to find ancestors.\ncs: The ClusterSequence object containing the jet history.\n\nReturns\n\nAn array of indices representing the ancestors of the given jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_dij_dist-NTuple{4, Any}","page":"Internal API","title":"JetReconstruction.get_dij_dist","text":"get_dij_dist(nn_dist, kt2_1, kt2_2, R2)\n\nCompute the dij metric distance between two jets.\n\nArguments\n\nnn_dist: The nearest-neighbor distance between two jets.\nkt2_1: The squared momentum metric value of the first jet.\nkt2_2: The squared momentum metric value of the second jet.\nR2: The jet radius parameter squared.\n\nReturns\n\nThe distance between the two jets.\n\nIf kt2_2 is equal to 0.0, then the first jet doesn't actually have a valid  neighbour, so it's treated as a single jet adjacent to the beam.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_tile-Tuple{JetReconstruction.TilingDef, AbstractFloat, AbstractFloat}","page":"Internal API","title":"JetReconstruction.get_tile","text":"get_tile(tiling_setup::TilingDef, eta::AbstractFloat, phi::AbstractFloat)\n\nGiven a tiling_setup object, eta and phi values, this function calculates the tile indices for the given eta and phi values.\n\nArguments\n\ntiling_setup: A TilingDef object that contains the tiling setup parameters.\neta: The eta value for which to calculate the tile index.\nphi: The phi value for which to calculate the tile index.\n\nReturns\n\nieta: The tile index along the eta direction.\niphi: The tile index along the phi direction.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.get_tile_cartesian_indices-Tuple{JetReconstruction.TilingDef, Int64}","page":"Internal API","title":"JetReconstruction.get_tile_cartesian_indices","text":"get_tile_linear_index(tiling_setup::TilingDef, i_η::Int, i_ϕ::Int)\n\nCompute the linear index of a tile in a tiled setup. This is much faster in this function than using the LinearIndices construct (like x100, which is bonkers, but there you go...)\n\nArguments\n\ntiling_setup::TilingDef: The tiling setup defining the number of tiles in each dimension.\ni_η::Int: The index of the tile in the η dimension.\ni_ϕ::Int: The index of the tile in the ϕ dimension.\n\nReturns\n\nThe linear index of the tile.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.initial_history-Tuple{Any}","page":"Internal API","title":"JetReconstruction.initial_history","text":"initial_history(particles)\n\nCreate an initial history for the given particles.\n\nArguments\n\nparticles: The initial vector of stable particles.\n\nReturns\n\nhistory: An array of HistoryElement objects.\nQtot: The total energy in the event.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.insert!-Tuple{JetReconstruction.TiledJet, JetReconstruction.TiledJet}","page":"Internal API","title":"JetReconstruction.insert!","text":"insert!(nextjet::TiledJet, jettomove::TiledJet)\n\nInserts a TiledJet object into the linked list of TiledJet objects, before the nextjet object. The jet to move can be an isolated jet, a jet from another list or a jet from the same list\n\nArguments\n\nnextjet::TiledJet: The TiledJet object after which jettomove should be inserted.\njettomove::TiledJet: The TiledJet object to be inserted.\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.is_ee-Tuple{JetReconstruction.JetAlgorithm.Algorithm}","page":"Internal API","title":"JetReconstruction.is_ee","text":"is_ee(algorithm::JetAlgorithm.Algorithm)\n\nCheck if the algorithm is a e+e- reconstruction algorithm.\n\nReturns\n\ntrue if the algorithm is a e+e- reconstruction algorithm, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.is_pp-Tuple{JetReconstruction.JetAlgorithm.Algorithm}","page":"Internal API","title":"JetReconstruction.is_pp","text":"is_pp(algorithm::JetAlgorithm.Algorithm)\n\nCheck if the algorithm is a pp reconstruction algorithm.\n\nReturns\n\ntrue if the algorithm is a pp reconstruction algorithm, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.isvalid-Tuple{JetReconstruction.TiledJet}","page":"Internal API","title":"JetReconstruction.isvalid","text":"isvalid(t::TiledJet)\n\nCheck if a TiledJet is valid, by seeing if it is not the noTiledJet object.\n\nArguments\n\nt::TiledJet: The TiledJet object to check.\n\nReturns\n\nBool: true if the TiledJet object is valid, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.jet_ranks-Tuple{ClusterSequence}","page":"Internal API","title":"JetReconstruction.jet_ranks","text":"jet_ranks(clusterseq::ClusterSequence; compare_fn = JetReconstruction.pt)\n\nCompute the ranks of jets in a given ClusterSequence object based on a specified comparison function.\n\nArguments\n\nclusterseq::ClusterSequence: The ClusterSequence object containing the jets to rank.\ncompare_fn = JetReconstruction.pt: The comparison function used to determine the order of the jets. Defaults to JetReconstruction.pt, which compares jets based on their transverse momentum.\n\nReturns\n\nA dictionary mapping each jet index to its rank.\n\nNote\n\nThis is a utility function that can be used to rank initial clusters based on a specified jet property. It can be used to assign a consistent \"rank\" to each reconstructed jet in the cluster sequence, which is useful for stable plotting of jet outputs.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.m-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.m","text":"m(p::PseudoJet)\n\nCompute the invariant mass of a PseudoJet object. By convention if m^2 < 0, then -sqrt{(-m^2)} is returned.\n\nArguments\n\np::PseudoJet: The PseudoJet object for which to compute the invariant mass.\n\nReturns\n\nThe invariant mass of the PseudoJet object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.m2-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.m2","text":"m2(p::PseudoJet)\n\nCalculate the invariant mass squared (m^2) of a PseudoJet.\n\nArguments\n\np::PseudoJet: The PseudoJet object for which to calculate the invariant mass squared.\n\nReturns\n\nThe invariant mass squared (m^2) of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.mag-Tuple{T} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.mag","text":"mag(jet::T) where {T <: FourMomentum}\n\nReturn the magnitude of the momentum of a jet, |p|.\n\nReturns\n\nThe magnitude of the jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.mass-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.mass","text":"mass(p::PseudoJet)\n\nCompute the invariant mass (alias for m(p)).\n\nArguments\n\np::PseudoJet: The PseudoJet object for which to compute the mass.\n\nReturns\n\nThe mass of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.mass2","page":"Internal API","title":"JetReconstruction.mass2","text":"Alias for m2 function\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#JetReconstruction.merge_steps-Tuple{ClusterSequence}","page":"Internal API","title":"JetReconstruction.merge_steps","text":"merge_steps(clusterseq::ClusterSequence)\n\nCompute the number of jet-jet merge steps in a cluster sequence. This is useful to give the number of meaningful recombination steps in a jet reconstruction sequence (beam merge steps are not counted).\n\nArguments\n\nclusterseq::ClusterSequence: The cluster sequence object.\n\nReturns\n\nmerge_steps::Int: The number of merge steps.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.open_with_stream-Tuple{AbstractString}","page":"Internal API","title":"JetReconstruction.open_with_stream","text":"open_with_stream(fname::AbstractString)\n\nOpen a file with a stream decompressor if it is compressed with gzip or zstd, otherwise as a normal file.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.phi-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.phi","text":"phi(p::PseudoJet)\n\nCompute the ϕ angle of a PseudoJet object p.\n\nNote this function is a wrapper for phi_02pi(p).\n\nArguments\n\np::PseudoJet: The PseudoJet object for which to compute the azimuthal angle.\n\nReturns\n\nThe azimuthal angle of p in the range [0, 2π).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.phi_02pi-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.phi_02pi","text":"phi_02pi(p::PseudoJet)\n\nCompute the azimuthal angle of a PseudoJet object p in the range [0, 2π).\n\nArguments\n\np::PseudoJet: The PseudoJet object for which to compute the azimuthal angle.\n\nReturns\n\nThe azimuthal angle of p in the range [0, 2π).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.pt-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.pt","text":"pt(p::PseudoJet)\n\nCompute the scalar transverse momentum (pt) of a PseudoJet.\n\nArguments\n\np::PseudoJet: The PseudoJet object for which to compute the transverse momentum.\n\nReturns\n\nThe transverse momentum (pt) of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.pt2-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.pt2","text":"pt2(p::PseudoJet)\n\nGet the squared transverse momentum of a PseudoJet.\n\nArguments\n\np::PseudoJet: The PseudoJet object.\n\nReturns\n\nThe squared transverse momentum of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.px-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.px","text":"px(p::PseudoJet)\n\nReturn the x-component of the momentum of a PseudoJet.\n\nArguments\n\np::PseudoJet: The PseudoJet object.\n\nReturns\n\nThe x-component of the momentum of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.py-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.py","text":"py(p::PseudoJet)\n\nReturn the y-component of the momentum of a PseudoJet.\n\nArguments\n\np::PseudoJet: The PseudoJet object.\n\nReturns\n\nThe y-component of the momentum of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.pz-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.pz","text":"pz(p::PseudoJet)\n\nReturn the z-component of the momentum of a PseudoJet.\n\nArguments\n\np::PseudoJet: The PseudoJet object.\n\nReturns\n\nThe z-component of the momentum of the PseudoJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.rapidity-Tuple{PseudoJet}","page":"Internal API","title":"JetReconstruction.rapidity","text":"rapidity(p::PseudoJet)\n\nCompute the rapidity of a PseudoJet object.\n\nArguments\n\np::PseudoJet: The PseudoJet object for which to compute the rapidity.\n\nReturns\n\nThe rapidity of the PseudoJet object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.recluster-Tuple{PseudoJet, ClusterSequence}","page":"Internal API","title":"JetReconstruction.recluster","text":"recluster(jet, clusterseq; R = 1.0, algorithm = JetAlgorithm.CA) -> ClusterSequence\n\nReclusters the constituents of a given jet jet with a different clustering algorithm algorithm and different jet radius R.\n\nArguments\n\njet::PseudoJet: The jet whose constituents are to be reclustered.\nclusterseq::ClusterSequence: The cluster sequence from which the original jet is obtained.\nR = 1.0: The new jet radius.\nalgorithm::JetAlgorithm.Algorithm = JetAlgorithm.CA: The new clustering method.\n\nReturns\n\nClusterSequence: The new cluster sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.reco_state-Union{Tuple{T}, Tuple{ClusterSequence{T}, Any}} where T<:JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.reco_state","text":"reco_state(cs::ClusterSequence, pt_ranks; iteration=0)\n\nThis function returns the reconstruction state of a ClusterSequence object based on a given iteration number in the reconstruction.\n\nArguments\n\ncs::ClusterSequence: The ClusterSequence object to update.\nranks: The ranks of the original clusters, that are inherited by pseudojets\n\nduring the reconstruction process.\n\niteration=0: The iteration number to consider for updating the reconstruction state (0 represents the initial state).\nignore_beam_merge=true: Ignore beam merging steps in the reconstruction (which produce no change in status).\n\nReturns\n\nA dictionary representing a snapshot of the reconstruction state.\n\nDetails\n\nThe function starts by initializing the reconstruction state with the initial particles. Then, it walks over the iteration sequence and updates the reconstruction state based on the history of recombination and finalization/beam merger steps.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.rightneighbours-Tuple{Int64, JetReconstruction.Tiling}","page":"Internal API","title":"JetReconstruction.rightneighbours","text":"rightneighbours(center::Int, tiling::Tiling)\n\nCompute the indices of the right neighbors of a given center index in a tiling. This is used in the initial sweep to calculate the nearest neighbors, where the search between jets for the nearest neighbour is bi-directional, thus when a tile is considered only the right neighbours are needed to compare jet distances as the left-hand tiles have been done from that tile already.\n\nArguments\n\ncenter::Int: The center index.\ntiling::Tiling: The tiling object.\n\nReturns\n\nSurrounding: An object containing the indices of the right neighbors.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.set_momentum!-Tuple{PseudoJet, Vararg{Any, 4}}","page":"Internal API","title":"JetReconstruction.set_momentum!","text":"set_momentum!(j::PseudoJet, px, py, pz, E)\n\nSet the momentum components and energy of a PseudoJet object.\n\nArguments\n\nj::PseudoJet: The PseudoJet object to set the momentum for.\npx: The x-component of the momentum.\npy: The y-component of the momentum.\npz: The z-component of the momentum.\nE: The energy of the particle.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.set_nearest_neighbours!-Tuple{ClusterSequence, JetReconstruction.Tiling, Vector{JetReconstruction.TiledJet}}","page":"Internal API","title":"JetReconstruction.set_nearest_neighbours!","text":"set_nearest_neighbours!(clusterseq::ClusterSequence, tiling::Tiling, tiledjets::Vector{TiledJet})\n\nThis function sets the nearest neighbor information for all jets in the tiledjets vector.\n\nArguments\n\nclusterseq::ClusterSequence: The cluster sequence object.\ntiling::Tiling: The tiling object.\ntiledjets::Vector{TiledJet}: The vector of tiled jets.\n\nReturns\n\nNNs::Vector{TiledJet}: The vector of nearest neighbor jets.\ndiJ::Vector{Float64}: The vector of diJ values.\n\nThe function iterates over each tile in the tiling and sets the nearest neighbor information for each jet in the tile. It then looks for neighbor jets in the neighboring tiles and updates the nearest neighbor information accordingly. Finally, it creates the diJ table and returns the vectors of nearest neighbor jets and diJ values.\n\nNote: The diJ values are calculated as the kt distance multiplied by R^2.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.setup_tiling-Union{Tuple{T}, Tuple{Vector{T}, AbstractFloat}} where T<:AbstractFloat","page":"Internal API","title":"JetReconstruction.setup_tiling","text":"setup_tiling(eta::Vector{T}, Rparam::AbstractFloat) where T <: AbstractFloat\n\nThis function sets up the tiling parameters for a reconstruction given a vector of rapidities eta and a radius parameter Rparam.\n\nArguments\n\neta::Vector{T}: A vector of rapidities.\nRparam::AbstractFloat: The jet radius parameter.\n\nReturns\n\ntiling_setup: A TilingDef object containing the tiling setup parameters.\n\nDescription\n\nThe function first decides the tile sizes based on the Rparam value. It then determines the number of tiles in the phi direction (n_tiles_phi) based on the tile size. Next, it determines the rapidity extent of the input eta vector and adjusts the values accordingly. Finally, it creates a TilingDef object with the calculated tiling parameters and returns it.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.surrounding-Tuple{Int64, JetReconstruction.Tiling}","page":"Internal API","title":"JetReconstruction.surrounding","text":"surrounding(center::Int, tiling::Tiling)\n\nCompute the surrounding indices of a given center index in a tiling.\n\nArguments\n\ncenter::Int: The center index.\ntiling::Tiling: The tiling object.\n\nReturns\n\nSurrounding: An object containing the surrounding indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.tile_index-Tuple{Any, Float64, Float64}","page":"Internal API","title":"JetReconstruction.tile_index","text":"tile_index(tiling_setup, eta::Float64, phi::Float64)\n\nCompute the tile index for a given (eta, phi) coordinate.\n\nArguments\n\ntiling_setup: The tiling setup object containing the tile size and number of tiles.\neta::Float64: The eta coordinate.\nphi::Float64: The phi coordinate.\n\nReturns\n\nThe tile index corresponding to the (eta, phi) coordinate.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.tiledjet_remove_from_tiles!-Tuple{Any, Any}","page":"Internal API","title":"JetReconstruction.tiledjet_remove_from_tiles!","text":"tiledjet_remove_from_tiles!(tiling, jet)\n\nRemove a jet from the given tiling structure.\n\nArguments\n\ntiling: The tiling structure from which the jet will be removed.\njet: The jet to be removed from the tiling structure.\n\nDescription\n\nThis function removes a jet from the tiling structure. It adjusts the linked list to be consistent with the removal of the jet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.tiledjet_set_jetinfo!-Tuple{JetReconstruction.TiledJet, ClusterSequence, JetReconstruction.Tiling, Any, Any, Any}","page":"Internal API","title":"JetReconstruction.tiledjet_set_jetinfo!","text":"tiledjet_set_jetinfo!(jet::TiledJet, clusterseq::ClusterSequence, tiling::Tiling, jets_index, R2, p)\n\nInitialise a tiled jet from a PseudoJet (using an index into our ClusterSequence)\n\nArguments:\n\njet::TiledJet: The TiledJet object to set the information for.\nclusterseq::ClusterSequence: The ClusterSequence object containing the jets.\ntiling::Tiling: The Tiling object containing the tile information.\njets_index: The index of the jet in the ClusterSequence.\nR2: The jet radius parameter squared.\np: The power to raise the pt2 value to.\n\nThis function sets the eta, phi, kt2, jetsindex, NNdist, NN, tile_index, previous, and next fields of the TiledJet object.\n\nReturns:\n\nnothing\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.upd_nn_crosscheck!-Tuple{Int64, Int64, Int64, Vararg{Any, 5}}","page":"Internal API","title":"JetReconstruction.upd_nn_crosscheck!","text":"upd_nn_crosscheck!(i, from, to, rapidity_array, phi_array, R2, nndist, nn)\n\nUpdate the nearest neighbor information for a given particle index i against all particles in the range indexes from to to. The function updates the nndist and nn arrays with the nearest neighbor distance and index respectively, both for particle i and the checked particles [from:to] (hence crosscheck).\n\nArguments\n\ni::Int: The index of the particle to update and check against.\nfrom::Int: The starting index of the range of particles to check against.\nto::Int: The ending index of the range of particles to check against.\nrapidity_array: An array containing the rapidity values of all particles.\nphi_array: An array containing the phi values of the all particles.\nR2: The squared jet distance threshold for considering a particle as a neighbour.\nnndist: The array that stores the nearest neighbor distances.\nnn: The array that stores the nearest neighbor indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.upd_nn_nocross!-Tuple{Int64, Int64, Int64, Vararg{Any, 5}}","page":"Internal API","title":"JetReconstruction.upd_nn_nocross!","text":"upd_nn_nocross!(i, from, to, rapidity_array, phi_array, R2, nndist, nn)\n\nUpdate the nearest neighbor information for a given particle index i against all particles in the range indexes from to to. The function updates the nndist and nn arrays with the nearest neighbor distance and index respectively, only for particle i (hence nocross).\n\nArguments\n\ni::Int: The index of the particle to update and check against.\nfrom::Int: The starting index of the range of particles to check against.\nto::Int: The ending index of the range of particles to check against.\nrapidity_array: An array containing the rapidity values of all particles.\nphi_array: An array containing the phi values of the all particles.\nR2: The squared jet distance threshold for considering a particle as a neighbour.\nnndist: The array that stores the nearest neighbor distances.\nnn: The array that stores the nearest neighbor indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.upd_nn_step!-NTuple{12, Any}","page":"Internal API","title":"JetReconstruction.upd_nn_step!","text":"upd_nn_step!(i, j, k, N, Nn, kt2_array, rapidity_array, phi_array, R2, nndist, nn, nndij)\n\nUpdate the nearest neighbor information after a jet merge step.\n\nArguments:\n\ni: Index of the first particle in the last merge step.\nj: Index of the second particle in the last merge step.\nk: Index of the current particle for which the nearest neighbour will be updated.\nN: Total number of particles (currently valid array indexes are [1:N]).\nNn: Number of nearest neighbors to consider.\nkt2_array: Array of transverse momentum squared values.\nrapidity_array: Array of rapidity values.\nphi_array: Array of azimuthal angle values.\nR2: Distance threshold squared for nearest neighbors.\nnndist: Array of nearest neighbor geometric distances.\nnn: Array of nearest neighbor indices.\nnndij: Array of metric distances between particles.\n\nThis function updates the nearest neighbor information for the current particle k by considering the distances to particles i and j. It checks if the distance between k and i is smaller than the current nearest neighbor distance for k, and updates the nearest neighbor information accordingly. It also updates the nearest neighbor information for i if the distance between k and i is smaller than the current nearest neighbor distance for i. Finally, it checks if the nearest neighbor of k is the total number of particles Nn and updates it to j if necessary.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.η","page":"Internal API","title":"JetReconstruction.η","text":"const η = eta\n\nAlias for the pseudorapidity function, eta.\n\n\n\n\n\n","category":"function"},{"location":"lib/internal/#JetReconstruction.FourMomentum","page":"Internal API","title":"JetReconstruction.FourMomentum","text":"Interface for composite types that includes fields px, py, py, and E that represents the components of a four-momentum vector.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.HistoryElement","page":"Internal API","title":"JetReconstruction.HistoryElement","text":"struct HistoryElement\n\nA struct holding a record of jet mergers and finalisations\n\nFields:\n\nparent1: Index in history where first parent of this jet was created (NonexistentParent if this jet is an original particle)\nparent2: Index in history where second parent of this jet was created (NonexistentParent if this jet is an original particle); BeamJet if this history entry just labels the fact that the jet has recombined with the beam)\nchild: Index in history where the current jet is recombined with another jet to form its child. It is Invalid if this jet does not further recombine.\njetp_index: Index in the jets vector where we will find the PseudoJet object corresponding to this jet (i.e. the jet created at this entry of the history). NB: if this element of the history corresponds to a beam recombination, then jetp_index=Invalid.\ndij: The distance corresponding to the recombination at this stage of the clustering.\nmax_dij_so_far: The largest recombination distance seen so far in the clustering history.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.HistoryElement-Tuple{Any}","page":"Internal API","title":"JetReconstruction.HistoryElement","text":"HistoryElement(jetp_index)\n\nConstructs a HistoryElement object with the given jetp_index, used for initialising the history with original particles.\n\nArguments\n\njetp_index: The index of the jetp.\n\nReturns\n\nA HistoryElement object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.JetWithAncestors","page":"Internal API","title":"JetReconstruction.JetWithAncestors","text":"struct JetWithAncestors{T <: FourMomentum}\n\nA struct representing a jet with its origin ancestors.\n\nFields\n\nself::T: The jet object itself.\njetp_index::Int: The index of the jet in the corresponding cluster sequence.\nancestors::Set{Int}: A set of indices representing the jetp_indexes of ancestors of the jet (in the cluster sequence).\njet_rank::Int: The rank of the jet based on a comparison of all of the jet's ancestors\n\nNote\n\nThis structure needs its associated cluster sequence origin to be useful.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.Surrounding","page":"Internal API","title":"JetReconstruction.Surrounding","text":"struct Surrounding{N}\n\nStructure used for iterating over neighbour tiles.\n\nFields\n\nindices::NTuple{N, Int}: A tuple of N integers representing the indices.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.TiledJet","page":"Internal API","title":"JetReconstruction.TiledJet","text":"mutable struct TiledJet\n\nTiledJet represents a jet in a tiled algorithm for jet reconstruction, with additional information to track the jet's position in the tiled structures.\n\nFields\n\nid::Int: The ID of the jet.\neta::Float64: The rapidity of the jet.\nphi::Float64: The azimuthal angle of the jet.\nkt2::Float64: The transverse momentum squared of the jet.\nNN_dist::Float64: The distance to the nearest neighbor.\njets_index::Int: The index of the jet in the jet array.\ntile_index::Int: The index of the tile in the tile array.\ndij_posn::Int: The position of this jet in the dij compact array.\nNN::TiledJet: The nearest neighbor.\nprevious::TiledJet: The previous jet.\nnext::TiledJet: The next jet.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.TiledJet-Tuple{Any}","page":"Internal API","title":"JetReconstruction.TiledJet","text":"TiledJet(id)\n\nConstructs a TiledJet object with the given id and initializes its properties to zero.\n\nArguments\n\nid: The ID of the TiledJet object.\n\nReturns\n\nA TiledJet object with the specified id and values set to zero or noTiledJet.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.Tiling","page":"Internal API","title":"JetReconstruction.Tiling","text":"struct Tiling\n\nThe Tiling struct represents a tiling configuration for jet reconstruction.\n\nFields\n\nsetup::TilingDef: The tiling definition used for the configuration.\ntiles::Matrix{TiledJet}: A matrix of tiled jets, containing the first jet in each tile (then the linked list of the first jet is followed to get access to all jets in this tile).\npositions::Matrix{Int}: Used to track tiles that are on the edge of ϕ array, where neighbours need to be wrapped around.\ntags::Matrix{Bool}: The matrix of tags indicating whether a tile is valid or not (set to false initially, then true when the tile has been setup properly).\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.Tiling-Tuple{JetReconstruction.TilingDef}","page":"Internal API","title":"JetReconstruction.Tiling","text":"Tiling(setup::TilingDef)\n\nConstructs a initial Tiling object based on the provided setup parameters.\n\nArguments\n\nsetup::TilingDef: The setup parameters for the tiling.\n\nReturns\n\nA Tiling object.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/#JetReconstruction.TilingDef","page":"Internal API","title":"JetReconstruction.TilingDef","text":"struct TilingDef\n\nA struct representing the definition of a specific tiling scheme.\n\nFields\n\n_tiles_eta_min::Float64: The minimum rapidity of the tiles.\n_tiles_eta_max::Float64: The maximum rapidity of the tiles.\n_tile_size_eta::Float64: The size of a tile in rapidity (usually R^2).\n_tile_size_phi::Float64: The size of a tile in phi (usually a bit more than R^2).\n_n_tiles_eta::Int: The number of tiles across rapidity.\n_n_tiles_phi::Int: The number of tiles across phi.\n_n_tiles::Int: The total number of tiles.\n_tiles_ieta_min::Int: The minimum rapidity tile index.\n_tiles_ieta_max::Int: The maximum rapidity tile index.\n\nConstructor\n\nTilingDef(_tiles_eta_min, _tiles_eta_max, _tile_size_eta, _tile_size_phi,\n\t_n_tiles_eta, _n_tiles_phi, _tiles_ieta_min, _tiles_ieta_max)\n\nConstructs a TilingDef object with the given parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.neighbour_tiles","page":"Internal API","title":"JetReconstruction.neighbour_tiles","text":"struct neighbour_tiles\n\nA struct representing the neighbouring tiles.\n\nA struct for iterating over all neighbour tiles for a given Cartesian tile index. These are the tiles above and to the right of the given tile (X=included, O=not included):\n\nXXX\nX.X\nXXX\n\nNote, rapidity coordinate must be in range, ϕ coordinate wraps\n\nFields\n\nn_η::Int: Number of η tiles\nn_ϕ::Int: Number of ϕ tiles\nstart_η::Int: Centre η tile coordinate\nstart_ϕ::Int: Centre ϕ tile coordinate\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/#JetReconstruction.rightmost_tiles","page":"Internal API","title":"JetReconstruction.rightmost_tiles","text":"struct rightmost_tiles\n\nA struct for iterating over rightmost tiles for a given Cartesian tile index. These are the tiles above and to the right of the given tile (X=included, O=not included):\n\nXXX\nO.X\nOOO\n\nNote, rapidity coordinate must be in range, ϕ coordinate wraps\n\nFields\n\nn_η::Int: Number of η tiles\nn_ϕ::Int: Number of ϕ tiles\nstart_η::Int: Centre η tile coordinate\nstart_ϕ::Int: Centre ϕ tile coordinate\n\n\n\n\n\n","category":"type"},{"location":"helpers/#Jet-Helper-Functions","page":"Jet Helpers","title":"Jet Helper Functions","text":"","category":"section"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"These functions are provided as a convenient way to work with the results of jet reconstruction.","category":"page"},{"location":"helpers/#Jet-Pair-Helpers","page":"Jet Helpers","title":"Jet Pair Helpers","text":"","category":"section"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"pt_fraction","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"Returns the transverse momentum fraction in the softer of the two jets.","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"kt_scale","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"Returns the transverse momentum scale between two jets, the product of the smaller p_T and the angular separation in the the η-ϕ plane.","category":"page"},{"location":"helpers/#Conversion-Functions","page":"Jet Helpers","title":"Conversion Functions","text":"","category":"section"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"lorentzvector","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"Return a cartesian LorentzVector from a jet.","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"lorentzvector_cyl","category":"page"},{"location":"helpers/","page":"Jet Helpers","title":"Jet Helpers","text":"Return a cylindrical LorentzVectorCyl from a jet.","category":"page"},{"location":"substructure/#Jet-Substructure","page":"Substructure","title":"Jet Substructure","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Jet substructure techniques provide powerful tools for analyzing and refining the properties of jets. Below are some of the key jet substructure functions, that are available.","category":"page"},{"location":"substructure/#Mass-Drop-Tagging","page":"Substructure","title":"Mass Drop Tagging","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"mass_drop(jet::PseudoJet, clusterseq::ClusterSequence, tag::MassDropTagger) -> PseudoJet","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The mass_drop function identifies subjets in a jet that pass the mass drop tagging condition. To use the mass_drop function:","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Configure the MassDropTagger with parameters tailored to the expected mass drop and distance thresholds for analysis.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"tagger = MassDropTagger(mu=0.67, y=0.09)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Apply the mass_drop function to the jet and its clustering sequence.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"tagged_jet = mass_drop(jet, clusterseq, tagger)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"If the jet is tagged successfully, the function returns the identified subjet. Else it returns PseudoJet(0.0, 0.0, 0.0, 0.0).","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"","category":"page"},{"location":"substructure/#Soft-Drop-Tagging","page":"Substructure","title":"Soft Drop Tagging","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"soft_drop(jet::PseudoJet, clusterseq::ClusterSequence, tag::SoftDropTagger) -> PseudoJet","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The soft_drop function applies soft-drop grooming to remove soft, wide-angle radiation from jets. It reclusters the jet with a specified radius and clustering method, iteratively checking the soft-drop condition on subjets. To use the soft_drop function:","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Construct the SoftDropTagger by defining the parameters for the grooming process, such as the energy fraction (zcut) and angular exponent (b)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"tagger = SoftDropTagger(zcut=0.1, b=2.0)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"By default, the reclustering radius is set to 1.0 which can be modified by defing the tagger object as","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"tagger = SoftDropTagger(zcut=0.1, b=2.0, cluster_rad=0.4)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Apply the soft_drop function to the jet and its clustering sequence.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"tagged_jet = soft_drop(jet, clusterseq, tagger)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"If the jet is tagged successfully, the function returns the identified subjet. Else it returns nothing.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"","category":"page"},{"location":"substructure/#Jet-Filtering","page":"Substructure","title":"Jet Filtering","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"jet_filtering(jet::PseudoJet, clusterseq::ClusterSequence, filter::JetFilter) -> PseudoJet","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The jet_filtering function filters a jet to retain only the hardest subjets based on a specified radius and number. To use the function:","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Set the radius for subjet clustering and the number of hardest subjets to retain in a JetFilter method.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"filter = JetFilter(filter_radius=0.3, num_hardest_jets=3)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Apply the jet_filtering function to refine the jet.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"filtered_jet = jet_filtering(jet, clusterseq, filter)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The function returns the filtered jet that retains only the most significant subjets, reducing noise.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"","category":"page"},{"location":"substructure/#Jet-Trimming","page":"Substructure","title":"Jet Trimming","text":"","category":"section"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"jet_trimming(jet::PseudoJet, clusterseq::ClusterSequence, trim::JetTrim) -> PseudoJet","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The jet_trimming function trims a jet by removing subjets with transverse momentum below a specified fraction of the main jet's momentum. This method cleans up jets by removing soft particles. To use this function:","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Configure the trimming radius and momentum fraction threshold in JetTrim","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"trim = JetTrim(trim_radius=0.3, trim_fraction=0.3, recluster_method=JetAlgorithm.CA)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"It is to be noted that the jet_trimming function reclusters the constituents of the jet using either C/A or kT algorithm, which needs to be specified.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"Apply the jet_trimming function to clean the jet.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"trimmed_jet = jet_trimming(jet, clusterseq, trim)","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"The function returns the trimmed jet.","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"","category":"page"},{"location":"substructure/","page":"Substructure","title":"Substructure","text":"For a more detailed guide to use these substructure modules, one can refer to the provided examples in the examples/substructure directory.","category":"page"},{"location":"strategy/#Algorithm-Strategy","page":"Reconstruction Strategies","title":"Algorithm Strategy","text":"","category":"section"},{"location":"strategy/","page":"Reconstruction Strategies","title":"Reconstruction Strategies","text":"For the pp algorithms three strategies are available for the different algorithms, which can be specified by passing the named argument strategy=... to the reconstruction.","category":"page"},{"location":"strategy/","page":"Reconstruction Strategies","title":"Reconstruction Strategies","text":"Strategy Name Notes Interface\nRecoStrategy.Best Dynamically switch strategy based on input particle density jet_reconstruct\nRecoStrategy.N2Plain Global matching of particles at each interaction (works well for low N) plain_jet_reconstruct\nRecoStrategy.N2Tiled Use tiles of radius R to limit search space (works well for higher N) tiled_jet_reconstruct","category":"page"},{"location":"strategy/","page":"Reconstruction Strategies","title":"Reconstruction Strategies","text":"Generally one can use the jet_reconstruct interface, shown above, as the Best strategy safely as the overhead is extremely low. That interface supports a strategy option to switch to a different option.","category":"page"},{"location":"strategy/","page":"Reconstruction Strategies","title":"Reconstruction Strategies","text":"For e^+e^- algorithms particle densities are low, so the only implementation is of the same type as N2Plain.","category":"page"},{"location":"examples/#Jet-Reconstruction-Examples","page":"Examples","title":"Jet Reconstruction Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Jet Reconstruction package has a number of example files that show how to usage. These are in the examples subdirectory of the package and can be browsed directly on GitHub.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note: because of extra dependencies in these scripts, one must use the Project.toml file in the examples directory.","category":"page"},{"location":"examples/#Standalone-Basic-Reconstruction-Examples","page":"Examples","title":"Standalone Basic Reconstruction Examples","text":"","category":"section"},{"location":"examples/#jetreco.jl","page":"Examples","title":"jetreco.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is a basic jet reconstruction example that shows how to call the package to perform a jet reconstruction, with different algorithms and (optionally) strategy, producing exclusive and inclusive jet selections.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia --project=examples examples/jetreco.jl --algorithm=AntiKt test/data/events.pp13TeV.hepmc3.gz\n...\njulia --project=examples examples/jetreco.jl --algorithm=Durham test/data/events.eeH.hepmc3.gz\n...\njulia --project=examples examples/jetreco.jl --maxevents=10 --strategy=N2Plain --algorithm=Kt --exclusive-njets=3 test/data/events.pp13TeV.hepmc3.gz\n...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are options to explicitly set the algorithm (use --help to see these).","category":"page"},{"location":"examples/#instrumented-jetreco.jl","page":"Examples","title":"instrumented-jetreco.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is a more sophisticated example that allows performance measurements to be made of the reconstruction, as well as profiling (flamegraphs and memory profiling). Use the --help option to see usage. e.g., to extract timing performance for the AntiKt algorithm using the tiled strategy:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia --project instrumented-jetreco.jl -S N2Tiled -A AntiKt --nsamples 100 ../test/data/events.hepmc3","category":"page"},{"location":"examples/#Visualisation","page":"Examples","title":"Visualisation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This subdirectory contains examples showing how to use built in support for visualising jets - either a final reconstruction state or an animation of the reconstruction process.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Particularly here the heavy Makie dependency is contained in the Project.toml file for these examples only.","category":"page"},{"location":"examples/#visualise-jets.jl","page":"Examples","title":"visualise-jets.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This script will produce a PNG/PDF showing the results of a jet reconstruction. This is a 3D plot where all the initial energy deposits are visualised, with colours that indicate in which final cluster the deposit ended up in.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia --project visualise-jets.jl -A AntiKt -R 1.0 ../../test/data/events.pp13TeV.hepmc3.gz test-pp.png","category":"page"},{"location":"examples/#visualise-jets.ipynb-and-visualise-jets-nb.ipynb","page":"Examples","title":"visualise-jets.ipynb and visualise-jets-nb.ipynb","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Similar to visualise-jets.jl these notebooks will produce a visualisation of jet reconstruction in the browser. This is a 3D plot where all the initial energy deposits are visualised, with colours that indicate in which final cluster the deposit ended up in.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first example is a Jupyter notebook, the second runs in Pluto.","category":"page"},{"location":"examples/#animate-reconstruction.jl","page":"Examples","title":"animate-reconstruction.jl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Performs jet reconstruction and then produces and animation of the process, showing how the jets merge from their different constituents.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia --project animate-reconstruction.jl -A AntiKt -R 1.0 ../../test/data/events.pp13TeV.hepmc3.gz test-pp.mp4","category":"page"},{"location":"examples/#EDM4hep","page":"Examples","title":"EDM4hep","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The examples/EDM4hep folder contains examples of using EDM4hep reconstructed particles as input to jet reconstruction. See the specific README.md file in that directory as well as EDM4hep Inputs.","category":"page"},{"location":"examples/#Jet-Constituents","page":"Examples","title":"Jet Constituents","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The examples/constituents folder shows an example of the two mechanisms to retrieve jet constituents.","category":"page"},{"location":"visualisation/#Jet-Visualisation-Documentation","page":"Visualisation","title":"Jet Visualisation Documentation","text":"","category":"section"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"Documentation for visualisation interfaces extension module.","category":"page"},{"location":"visualisation/#Plotting-and-Animation","page":"Visualisation","title":"Plotting and Animation","text":"","category":"section"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"(Image: illustration)","category":"page"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"To visualise the clustered jets as a 3d bar plot (see illustration above) Makie.jl is used. See the jetsplot function in ext/JetVisualisation.jl and its documentation for more. There are two worked examples in the examples directory of this package.","category":"page"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"The plotting code is a package extension and will load if the one of the Makie modules is loaded in the environment.","category":"page"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"The animatereco function will animate the reconstruction sequence, given a ClusterSequence object. See the function documentation below for the many options that can be customised.","category":"page"},{"location":"visualisation/#Function-Index","page":"Visualisation","title":"Function Index","text":"","category":"section"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"Pages = [\"visualisation.md\"]","category":"page"},{"location":"visualisation/#Jet-Visualisation-Public-Interfaces","page":"Visualisation","title":"Jet Visualisation Public Interfaces","text":"","category":"section"},{"location":"visualisation/","page":"Visualisation","title":"Visualisation","text":"Modules = [JetVisualisation]\nOrder = [:function]","category":"page"},{"location":"visualisation/#JetReconstruction.animatereco-Tuple{ClusterSequence, Any}","page":"Visualisation","title":"JetReconstruction.animatereco","text":"animatereco(cs::ClusterSequence, filename;\n            barsize_phi = 0.1,\n            barsize_y = 0.1,\n            colormap = :glasbey_category10_n256,\n            perspective = 0.5,\n            azimuth = 2.7,\n            elevation = 0.5,\n            framerate = 5,\n            ancestors = false,\n            Module = Makie)\n\nAnimate the jet reconstruction process and save it as a video file.\n\nArguments\n\ncs::ClusterSequence: The cluster sequence object containing the jets.\nfilename: The name of the output video file.\n\nOptional Arguments\n\nbarsize_phi=0.1: The size of the bars in the phi direction.\nbarsize_y=0.1: The size of the bars in the y direction.\ncolormap=:glasbey_category10_n256: The colormap to use for coloring the jets.\nperspective=0.5: The perspective of the plot.\nazimuth=2.7: The azimuth angle of the plot.\nelevation=0.5: The elevation angle of the plot.\nframerate=5: The framerate of the output video.\nend_frames=0: The number of static frames to show at the end of the animation. This can be useful to show the final state of the jets for a longer time.\ntitle=nothing: The title to add to the plot.\nancestors=false: Whether to include ancestors of the jets in the animation. When true the ancestors of the jets will be plotted as well, as height zero bars, with the same colour as the jet they are ancestors of.\nModule: The plotting module to use. Default is Makie.\n\nFor perspective, azimuth, and elevation, a single value can be passed for a fixed viewpoint, or a tuple of two values for a changing viewpoint. The viewpoint will then change linearly between the two values over the course of the animation.\n\nReturns\n\nfig: The figure object representing the final frame.\n\n\n\n\n\n","category":"method"},{"location":"visualisation/#JetReconstruction.jetsplot-Tuple{Any, Any}","page":"Visualisation","title":"JetReconstruction.jetsplot","text":"jetsplot(objects, idx_arrays; barsize_phi=0.1, barsize_eta=0.1, colormap=:glasbey_hv_n256, Module=Main)\n\nPlots a 3d bar chart that represents jets. Takes an objects array of objects to display and idx_arrays, an array of arrays with indices, where idx_arrays[i] gives indices of objects that form the jet number i. This function's signature might not be the most practical for the current version of the JetReconstruction.jl package, as it has been written during the early stage of development. There is now an overload of it that takes a ClusterSequence object as its argument.\n\nOptional arguments: barsize_phi::Real — width of a bar along the ϕ axis; barsize_eta::Real — width of a bar along the η axis; colormap::Symbol — Makie colour map; Module — the module where you have your Makie (see below);\n\n# example\nusing CairoMakie # use any other Makie that you have here\n\njetsplot([object1, object2, object3], [[1], [2, 3]])\n\nThe example above plots object1 as a separate jet in one colour and object2 and object3 together in another colour.\n\nThis function needs Makie.jl to work. You should install and import/use a specific backend yourself. jetsplot works with CairoMakie, WGLMakie, GLMakie, etc. Additionally, you can specify the module where you have your Makie explicitly:\n\nimport CairoMakie\njetsplot(my_objects, my_colour_arrays, Module=CairoMakie)\n\nimport GLMakie\njetsplot(my_objects, my_colour_arrays, Module=GLMakie)\n\nusing WGLMakie\njetsplot(my_objects, my_colour_arrays, Module=Main) #default\n\n\n\n\n\n","category":"method"},{"location":"visualisation/#JetReconstruction.jetsplot-Tuple{Any, ClusterSequence}","page":"Visualisation","title":"JetReconstruction.jetsplot","text":"jetsplot(objects, cs::ClusterSequence; barsize_phi=0.1, barsize_eta=0.1, colormap=:glasbey_hv_n256, Module=Main)\n\nPlots a 3d bar chart that represents jets. Takes objects, an array of objects to display (should be the same array you have passed to jet_reconstruct to get the cs::ClusterSequence), and the cs::ClusterSequence itself as arguments.\n\nOptional arguments: barsize_phi::Real — width of a bar along the ϕ axis; barsize_eta::Real — width of a bar along the η axis; colormap::Symbol — Makie colour map; Module — the module where you have your Makie (see below);\n\n# example\nusing CairoMakie # use any other Makie that you have here\njetsplot([object1, object2, object3], cluster_sequence_I_got_from_jet_reconstruct; Module=CairoMakie)\n\nThis function needs Makie.jl to work. You should install and import/use a specific backend yourself. jetsplot works with CairoMakie, WGLMakie, GLMakie, etc. Additionally, you can specify the module where you have your Makie explicitly:\n\nimport CairoMakie\njetsplot(my_objects, cs, Module=CairoMakie)\n\nimport GLMakie\njetsplot(my_objects, cs, Module=GLMakie)\n\nusing WGLMakie\njetsplot(my_objects, cs, Module=Main) #default\n\n\n\n\n\n","category":"method"},{"location":"#Jet-Reconstruction","page":"Home","title":"Jet Reconstruction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements sequential Jet Reconstruction (clustering) algorithms, which are used in high-energy physics as part of event reconstruction for pp and e^+e^- colliders.","category":"page"},{"location":"#Algorithms","page":"Home","title":"Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Algorithms used are based on the C++ FastJet package (https://fastjet.fr, hep-ph/0512210, arXiv:1111.6097), reimplemented natively in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The algorithms include anti-k_textT, Cambridge/Aachen, inclusive k_textT, generalised k_textT for pp events; and the Durham algorithm and generalised k_textT for e^+e^-.","category":"page"},{"location":"#Reconstruction-Interface","page":"Home","title":"Reconstruction Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main interface for reconstruction is jet_reconstruct, called as, e.g.,","category":"page"},{"location":"","page":"Home","title":"Home","text":"jet_reconstruct(particles; algorithm = JetAlgorithm.AntiKt, R = 1.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"or with some of the optional arguments,","category":"page"},{"location":"","page":"Home","title":"Home","text":"jet_reconstruct(particles; algorithm = JetAlgorithm.GenKt, R = 0.4, \n                p = 0.5, recombine = +, strategy = RecoStrategy.Best)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Where particles is a collection of 4-vector objects (see Input Particle Types) to reconstruct and the algorithm is either given explicitly or implied by the power value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the case of generalised k_T (for pp and e^+e^-) both the algorithm (GenKt, EEKt) and p are needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The R value determines the cone size; in the case of the Durham algorithm the R value is ignored.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The object returned is a ClusterSequence, which internally tracks all merge steps and is used for Inclusive and Exclusive Selections.","category":"page"},{"location":"#Algorithm-Types","page":"Home","title":"Algorithm Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each known algorithm is referenced using a JetAlgorithm scoped enum value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Algorithm Type name Notes\nanti-k_textT JetAlgorithm.AntiKt Implies p=-1\nCambridge/Aachen JetAlgorithm.CA Implies p=0\ninclusive k_textT JetAlgorithm.Kt Implies p=1\ngeneralised k_textT JetAlgorithm.GenKt For pp, value of p must also be specified\ne^+e- k_textT / Durham JetAlgorithm.Durham R value ignored and can be omitted\ngeneralised e^+e- k_textT JetAlgorithm.EEKt For e^+e^-, value of p must also be specified","category":"page"},{"location":"#pp-Algorithms","page":"Home","title":"pp Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the three pp algorithms with fixed p values, the p value can be given instead of the algorithm name. However, this should be considered deprecated and will be removed in a future release.","category":"page"},{"location":"#Strategy","page":"Home","title":"Strategy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generally one does not need to manually specify a strategy, but Algorithm Strategy describes how to do this, if desired.","category":"page"},{"location":"#Inclusive-and-Exclusive-Selections","page":"Home","title":"Inclusive and Exclusive Selections","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To obtain final jets both inclusive (p_T cut) and exclusive (n_jets or d_ij cut) selections are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"inclusive_jets(clusterseq::ClusterSequence, ptmin = 0.0)\nexclusive_jets(clusterseq::ClusterSequence; dcut = nothing, njets = nothing)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(For exclusive_jets either dcut or njets is needed, but not both.)","category":"page"},{"location":"#Sorting","page":"Home","title":"Sorting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sorting vectors is trivial in Julia, no special sorting methods are provided. As an example, to sort exclusive jets of 50 (usually GeV, depending on your EDM) from highest energy to lowest:","category":"page"},{"location":"","page":"Home","title":"Home","text":"sorted_jets = sort!(inclusive_jets(cs::ClusterSequence; ptmin=5.0), \n  by=JetReconstruction.energy, rev=true)","category":"page"},{"location":"#Jet-Constituents-and-Jet-Parents","page":"Home","title":"Jet Constituents and Jet Parents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two ways to retrieve jet constituents. The first way is just to retrieve the indexes of the constituent jets. These indexes refer to the original collection of particles passed in to the reconstruction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"constituent_indexes","category":"page"},{"location":"","page":"Home","title":"Home","text":"The alternative it to retrieve the actual jets from the reconstruction sequence. In this case the returned array contains references to the jet objects (of type T) used internally in the reconstruction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"constituents","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that in both these cases the cluster sequence object from the reconstruction is required (to avoid circular dependencies and improve memory management reconstructed jets do not contain a link back to their cluster sequence).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To retrieve a jet's parents:","category":"page"},{"location":"","page":"Home","title":"Home","text":"parent_jets","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will return a tuple of the target jet's parents, or nothing when one or both parents are missing (the only case when a jet has one parent is when it undergoes a beam merge step).","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Although it has been developed further since the CHEP2023 conference, the CHEP conference proceedings, 10.1051/epjconf/202429505017, should be cited if you use this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{refId0,\n    author = {{Stewart, Graeme Andrew} and {Gras, Philippe} and {Hegner, Benedikt} and {Krasnopolski, Atell}},\n    doi = {10.1051/epjconf/202429505017},\n    journal = {EPJ Web of Conf.},\n    pages = {05017},\n    title = {Polyglot Jet Finding},\n    url = {https://doi.org/10.1051/epjconf/202429505017},\n    volume = 295,\n    year = 2024,\n    eprint={2309.17309},\n    archivePrefix={arXiv},\n    primaryClass={hep-ex}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"The original paper on arXiv is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{stewart2023polyglot,\n      title={Polyglot Jet Finding}, \n      author={Graeme Andrew Stewart and Philippe Gras and Benedikt Hegner and Atell Krasnopolski},\n      year={2023},\n      eprint={2309.17309},\n      archivePrefix={arXiv},\n      primaryClass={hep-ex}\n}","category":"page"},{"location":"#Authors-and-Copyright","page":"Home","title":"Authors and Copyright","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Code in this package is authored by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Atell Krasnopolski <delta_atell@protonmail.com>\nGraeme A Stewart <graeme.andrew.stewart@cern.ch>\nPhilippe Gras <philippe.gras@cern.ch>","category":"page"},{"location":"","page":"Home","title":"Home","text":"and is Copyright 2022-2024 The Authors, CERN.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code is under the MIT License.","category":"page"}]
}
